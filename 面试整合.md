# Java基础

## 面向对象（编程特性）

### 重写与重载的区别

重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理 

重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

### 三大特征

- **继承**

  继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

- **封装**

  封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不 必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

- **多态**

  所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是 在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中 实现的方法，必须在由程序运行期间才能决定。 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方 法）。

### Java8新特性

- 允许接口添加非抽象方法的实现，只需要使用default关键字（默认方法），默认方法可以在子类上直接使用

- Lambda表达式，允许把函数作为一个方法的参数，可以加强代码可读性

  ```java
  //旧的比较器写法
  Collections.sort(names, new Comparator<String>() {
      @Override
      public int compare(String a, String b) {
          return b.compareTo(a);
      }
  });
  //Lambda表达式后
  Collections.sort(names, (String a, String b) -> b.compareTo(a));
  ```

- 方法与构造函数引用：方法引用提供了非常有用的语法，可以直接引用已有的java类或对象实例的方法或构造器。与lambda表达式使用，方法引用可以使余元的后遭更加紧凑简洁，减少冗余代码

  - 构造器引用 Class::new
  - 静态方法引用 Class::static_method
  - 某个类的成员方法的引用 Class::method
  - 某个实例对象的成员方法的引用 instance::method
  
  ```java
  //方法引用  Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用
  @FunctionalInterface
  interface Converter<F, T> {
      T convert(F from);
  }
  Converter<String, Integer> converter = Integer::valueOf;
  Integer converted = converter.convert("123");
  System.out.println(converted);   // 123
  
  
  //构造函数方法引用
  class Person {
      String firstName;
      String lastName;
    Person() {}
  
      Person(String firstName, String lastName) {
          this.firstName = firstName;
          this.lastName = lastName;
      }
  }
  //接下来我们指定一个用来创建Person对象的对象工厂接口：
  interface PersonFactory<P extends Person> {
      P create(String firstName, String lastName);
  }
  //这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：
  PersonFactory<Person> personFactory = Person::new;
  Person person = personFactory.create("Peter", "Parker");//我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。
  ```
  

### 接口和抽象类的区别

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可 以有非抽象的方法

2. 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 

3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。

4. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了 被重写所以不能使用 private 关键字修饰！）。 

5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

### final static this super

#### final

- 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的 变量，则在对其初始化之后便不能再让其指向另一个对象。 

-  当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

-  final修饰的方法不能被重写

  使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。 在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来 的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐 式地指定为 final。

#### static

**static 关键字主要有以下四种使用场景：**

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名` `类名.静态方法名()`
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

#### this

```java
class Manager {
    Employees[] employees;
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
    void report() { }
}
```

在上面的示例中，this关键字用于两个地方：

- this.employees.length：访问类Manager的当前实例的变量。
- this.report（）：调用类Manager的当前实例的方法。

此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。

#### super

super关键字用于从子类访问父类的变量和方法。 例如：

```java
public class Super {
    protected int number;
    protected showNumber() {
        System.out.println("number = " + number);
    }
}

public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 `showNumber（）` 方法。

**使用 this 和 super 要注意的问题：**

- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。

### 面向对象七大原则

**1.单一职责原则（Single-Resposibility Principle）**

  其核心思想为：**一个类，最好只做一件事，只有一个引起它的变化**。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。

**2.开放封闭原则（Open-Closed principle）**

  其核心思想是：**软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的**。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。
  实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。

**3.里氏替换原则（Liskov-Substituion Principle）**

  其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。
  **Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上**，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。**实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类**，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。
  Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。
  Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

**4.依赖倒置原则（Dependecy-Inversion Principle）**

  其核心思想是：**依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。**
  我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。
  抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。
  依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

**5.接口隔离原则（Interface-Segregation Principle）**

  其核心思想是：**使用多个小的专门的接口，而不要使用一个大的总接口。**
  具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。
  接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。
  分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

**6.迪米特法则（最少知道原则）**

  **一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。**

**7.合成复用原则**

  **原则是尽量使用合成/聚合的方式，而不是使用继承**

### 设计模式及其应用

#### JAVA I/O中的设计模式

**适配器模式**

适配器模式就是把一个类的接口变换成客户端所能接受的另一种接口，从而使两个接口不匹配而无法在一起工作的两个类能够在一起工作。通常被用在一个项目需要引用一些开源框架来一起工作时，这些框架的内部都有一些关于环境信息的接口，需要从外部引入，但是外部的接口不一定能匹配，在这种情况下，就需要适配器模式来转换接口。

![image-20200909135239433](/Users/sheva/Library/Application Support/typora-user-images/image-20200909135239433.png)

Java的I/O类库中有许多这样的需求，如将字符串转成字节数据保存到文件中，将字节数据变成数据流等。具体来说，InputStreamReader和OutputStreamWriter就是适配器的体现。InputStreamReader实现了Reader接口，并且持有InputStream的引用，其作用是将InputStream适配到Reader。源角色就是InputStream代表的实例对象，目标角色就是Reader类。OutputStreamWriter也是类似的方式。

**装饰器模式**

装饰器的作用是使得被装饰者功能更强大，而且装饰前后的使用方式不变。Java I/O类库中有许多不同的功能组合情况，这些不同的功能组合都是使用装饰器模式实现的。以FileInputStream为例，其类结构如下：

![image-20200909135358654](/Users/sheva/Library/Application Support/typora-user-images/image-20200909135358654.png)

由于java I/O库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是java I/O库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用 java I/O 库时，必须理解java I/O库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。
InputStream类是以抽象组件的形式存在，而FileInputStream就是具体组件，它实现了抽象接口的所有方法，并且持有InputStream对象的引用。FileInputStream就是一个装饰类，而BufferInputStream是这个装饰类的具体实现者，它给InputStream加入了新的功能，使得InputStream读取的数据保存在内存中，从而提高读取性能。

**适配器模式与装饰模式的区别**

适配模式是为了处理两个接口不一致，改变现有接口使其匹配。
装饰模式是在不改变现有接口的前提下，加入新的功能。

#### Tomcat中的设计模式

**门面模式**

Tomcat中门面设计模式使用得很多，因为Tomcat中有很多组件，每个组件要相互交互数据，用门面设计模式隔离数据是个很好的方法。

可以看到，HttpRequestFacade类封装了HttpRequest接口，能够提供数据，通过HttpRequestFacade访问到的数据被代理到HttpReauest中、通常被封装的对象都被设为Private或者Protectd的，防止在Facade中直接访问。

**观察者模式**

Tomcat中观察者模式也有多处使用，前面讲的控制组件生命周期的Lifecycle就是这 种模式的体现，还有对Servlet实例的创建、Session的管理、Container等都是同样的原理。 下面主要看一下Lifecycle的具体实现。

LifecycleListener代表的是抽象观察者，它定义一个lifecycleEvent 方法，这个方法就是当主题变化时要执行的方法。ServerLifecycleListener代表的是具体的 观察者，它实现了 LifecycleListener接口的方法，就是这个具体的观察者具体的实现方式。 Lifecycle接口代表的是抽象主题，它定义了管理观察者的方法和它所要做的其他方法。而 StandardServer代表的是具体主题，它实现了抽象主题的所有方法。这里Tomcat对观察者 做了扩展，谓加了另外两个类：LifecycleSupport和LifecycleEvent，它们作为辅助类扩展 了观察者的功能。LifecycleEvent使得可以定义事件类别，不同的事件可区别处理，更加灵活。LifecycleSupport类代理了主题对多观察者的管理，将这个管理抽出来统一实现，以 后如采修改只要修改LifecycleSupport类就可以了，不需要去修改所有的具体主题，因为 所有具体主题对观察者的操作都被代理给LifecycleSupport类了。这可以认为是观察者模式的改进版。

**责任链模式**

Tomcat 中一个最容易发现的设计模式就是责任链设计模式，这个设计模式也是 Tomcat 中 Contain设计的基础，整个容器就是通过一个链连接在一起的，这个链一直将请求正确地传递给最终处理请求的那个 Servlet 。在Tomcat中这种设计模式儿乎被完整地使用，Tomcat的容器设置就是责任链模式，从Engine到Host再到Cortex，一直到Wrapper都通过这个链传递请求

**命令模式**

Tomcat中命令模式在Connector和Container组件之间有体现，Tomcat作为一个应用 服务器，无疑会接收到很多请求，如何分配和执行这些请求是必须的功能。
Connector作为抽象请求者，HttpConnector作为具体请求者。HttpProcessor作为命令。 Container作为命令的抽象接受者，ContainerBase作为具体的接受者。客户端就是应用服务器Server组件了。Server首先创建命令请求者HttpConnector对象，然后创建命令 HttpProcessor对象。再把命令对象交给命令接受者ContainerBase容器来处理，命令最终是被Tomcat的Container执行的。命令可以以队列的方式进来，Container也可以以不同的 方式来处理请求，如HTTP1.0协议和HTTP1.1的处理方式就不同。

#### Spring中的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

  **工厂模式**

  工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**。

  **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

  主要解决：主要解决接口选择的问题。

  何时使用：我们明确地计划不同条件下创建不同实例时。

  如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

  是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能，解决方案是在控制
  器里面不能写字段。

- **代理设计模式** : Spring AOP 功能的实现。

  在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。

- **单例设计模式** : Spring 中的 Bean 默认都是单例的。

  保证一个类仅有一个实例，并提供一个访问它的全局访问点。
  spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定

- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

  Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

- **策略模式**

  Spring的事务管理机制就是典型的策略模式，Spring事务策略是通过PlatformTransactionManager接口实现的，它是整个Spring事务的核心。它是对事务策略的一个高度抽象，不依赖于任何具体的事务策略，而对于底层的具体的事务策略它相应的有不同的实现类。而对于不同的事务策略的切换通常由Spring容器来负责管理，应用程序既无须与具体的事务API耦合，也无须与特定的实现类耦合而将应用和持久化技术，事务API彻底分离开来。

## 集合 关键字 与数据结构

### String StringBuilder StringBuffer

- **可变性**: 简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串， private final char value[] ，所以 String 对象是不可变的。而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数 组保存字符串 char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自 行查阅源码。
- **线程安全性**：String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共 方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对 方法进行加同步锁，所以是非线程安全的
- **性能**：每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**为什么要定义成final**

因为在程序编写的过程中，会大量地用到String常量，如果每次声明一个String引用都要新建一个String对象，那么会造成空间的极大浪费。于是，在java的堆中开辟了一块存储空间String pool，用于存储String常量对象。当有多个String引用指向同样的String字符串时，实际上是指向的是同一个Sting pool中的对象，而不需要额外的创建对象。

**String不可变的好处**

1、以String作为HashMap的key，String的不可变保证了hash值的不可变。

2、String作为网络连接的参数，它的不可变性提供了安全性。

3、String不可变，所以线程安全。

### ArrayList LinkedList Vector

- 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 

- 底层数据结构： Arraylist 底层使用的是 Object 数组； LinkedList 底层使用的是 双向链表 数据结构 （JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
- 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元 素位置的影响。 比如：执行 add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末 尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要 执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于 add(E e) 方法的插入，删除元素 时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（ (add(int index, E element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插入。
-  是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就 是通过元素的序号快速获取元素对象(对应于 get(int index) 方法)。 5. 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空 间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据。

**与Vector区别**

- Vector所有方法都加同步
- ArrayList默认扩容为原来的1.5倍，Vector扩容为原来的2倍

### Hash系列

#### hashCode

hashCode的作用是获取哈希码，重写equals的时候必须重写hashcode方法。在将数据添加至hashSet时，会先通过该数据的hashCode来判断插入的位置，若发现已经有相符的hashcode出现时，再通过equals方法来判断对象是否相等，如果相等，则添加失败，否则不同就会散列至其他地方，这样就大大减少了equals的次数，增加了效率

- 如果两个对象相等，hashcode与equals必相等
- 若两个对象不同，则hashcode可能相等，但equals必然不相等
- 因此，如果equals方法被覆盖了，则hashcode也必须被覆盖

#### HashTable

Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类， 并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap， 因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全 的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。

#### HashMap（线程不安全）

- 底层通过数组+链表实现，当链表长度超过8时，转换为红黑树（如果数组长度没有超过64，会先将数组扩容）；hash冲突的概率服从泊松分布，大于8的概率极低；JDK1.8之前，链表使用头插法，后使用尾插法
- 初始容量为1>>4=16 负载因子为0.75f，当大于容量负载因子时，会触发扩容机制，每次扩容为原来容量的两倍，所有数据会进行rehash操作；长度必须为2的幂次方，这样有利于hash散列，减少哈希冲突（2进制位运算  hashcode与len - 1进行位运算）

#### ConcurrentHashMap（线程安全）

- 底层数据结构：1.7之前采用分段（采用Segment进行封装）数据+链表进行实现（Segment继承ReentrantLock加锁），1.8后底层与hashmap一致
- 线程安全方式： 1.7时采用分段所对整个桶进行了分割分段，每一把锁只锁一段数据，降低了锁的粒度，提高了并发度。到了1.8之后摒弃了分段Segment的概念，采用sync+cas的方式。其读取时不加锁，写入时使用sync+cas；通过cas操作尝试修改数据，通过sync锁住整个entry；这里用到了两个volatile变量，一个是数据节点node的val和next，保证CAS操作原子性；另一个是数组table，保证扩容时数组的CAS操作原子性；添加元素扩容的逻辑是：先将数据添加进去，再检查是否需要扩容，这样子读取操作读取的是旧表数据。

- **put操作**：首先通过 hash 找到对应链表过后， 查看是否是第一个object， 如果是， 直接用cas原则插入，无需加锁。然后， 如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。
- **get操作**： 根据key值计算hash，找到对应的index，如果没有元素就直接返回null，如果有的话，如果hash小于0，说明可能正在扩容或者是红黑树，则根据树的查找进行查找（根据新的数组），如果大于0，则为链表结构，依次遍历

**为什么舍弃分段锁**

- 加入多个分段锁浪费内存空间
- map放入时竞争同一个锁的概率非常小，分段锁反而造成更新等操作的长时间等待
- 提高GC效率

**为什么用synchronized 不用ReentranLock**

- **减少内存开销**
  假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。
- **获得JVM的支持**
  可重入锁毕竟是API这个级别的，后续的性能优化空间很小。
  synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。

#### HashMap与HashTable区别

- 线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
- 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在 代码中使用它；
- 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键 所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。
- 初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来 的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充 为2的幂次方大小（HashMap 中的 tableSizeFor() 方法保证，下面给出了源代码）。也就是说 HashMap 总 是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。
-  底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换 为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

### 树(平衡二叉树）

#### 红黑树的性质：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

#### 平衡二叉树的性质：

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。**但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间**，不过相对二叉查找树来说，时间上稳定了很多。

#### 红黑树与平衡二叉树区别： 

1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

2、平衡二叉树追求绝对平衡，条件苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

3、 如果插入一个node引起了树的不平衡，AVL和RB-Tree(红黑树)都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次(因为不需要严格的平衡，从根到叶子的最长的可能路径不多于最短的可能路径的两倍长)旋转以及修改节点的颜色，只需要O(1)的复杂度。

4、 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。

#### B+树

**B+树的概念**

- B+树包含两种节点，一种是非叶子节点（索引节点），一种是叶子节点（叶子节点存数据 非叶子节点存主键+指针）
- B+树与B树，最大的不同是**B+树的非叶子节点不保存数据，只用于索引**，所有数据都保存在叶子节点
- 非叶子节点最多有M - 1 个关键字，阶数M同时限制了叶子节点最多存储 M - 1 个记录
- 索引节点中的key都按照**从小到大**的顺序排列，对于内部节点中的一个key，左子树中的所有key都小于它，右子树中的key都**大于等于**它。叶子节点中的记录也按照key的大小排列
- **每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依关键字的大小从小到大顺序连接（范围查找特性）**

**优点**

- 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
- B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

**应用场景**

B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉,B树每个内节点有多个分支),**与红黑树相比,在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度**。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成,而CPU的速度非常快,所以B树的操作效率取决于访问磁盘的次数,关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少.

#### TreeMap

TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序， 也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。 在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。

### Synchronize锁

#### 内部原理

会持有对象的monitor对象（monitor对象存在于每个Java对象的对象头中，synchronize锁便是通过这种方式获取锁的），如果获取成功，进入，否则 等待

- **monitor**：
  - 每个对象都包含一个对象头信息（Markword 、Klass Pointer），其中锁信息存储在markword字段中
  - 每一个线程尝试获取锁的时候，首先会判断锁的标志位，如果是重量级锁，根据对应的指针信息找到对应的monitor对象，monitor持有两个队列，一个是等待队列一个是唤醒队列（entryList与waitList），多线程进入后，首先在等待队列进行等待，当一个线程获取到monitor对象后，设置owner为当前线程，同时计数count+1，如果中途wait中断，则进入waitList等待被唤醒
  - 锁标志位 00--->轻量级锁  01---->偏向锁  10---->重量级锁
- Sync关键字可以修饰**实例方法 静态方法  对象** 

#### 乐观锁与悲观锁

乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为 别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。 java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入 值是否一样，一样则更新，否则失败。

悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。 java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到， 才会转换为悲观锁，如 ReentranLock。

#### 锁升级过程

- 当线程首次获取锁的时候，修改markword标志位，表示偏向锁
- 当另一个线程需要获取锁时，通过CAS自旋操作获取锁，因为已经获取到锁，说明上一个线程已经释放资源，因此只要修改标志位，如果CAS失败，则表明存在并发可能，升级为轻量级锁
- 当多线程竞争时，通过CAS自旋操作获取锁（默认为10次）， 消耗CPU资源，但是不经过OS，不会引起用户态和内核态的切换；若自旋超过一定次数，则升级重量级锁，需要获取对象的监视器

#### Sync与Lock的区别（wait notify await signal区别）

- 两者都是可重入锁，可以再次获取自己的内部锁，有效避免了死锁的问题

- 两者都保证了可见性与互斥性

- Sync基于JVM（悲观锁），而Lock基于API（乐观锁， CAS），Lock需要在finally进行unlock操作

- Lock可以指定公平锁与非公平锁，而Sync是非公平锁。

- synchronize通过 wait notify实现等待 通知机制；而lock可以通过Condition接口的new Condition方法，其具有很好的灵活性，可以通过多路通知功能在一个lock对象中创建对个实例，在进程调度上更加灵活。

- Lock等待可中断，通过lock.lockInterruptibly()来实现这个机制，在获取锁的途中可以去做其他事，线程不用等待，而Sync需要阻塞等待

- ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个要么唤醒全部线程。

   Lock的好处，在第五点看来绑定多个Condition 可以精确唤醒.

#### Sync与volatile的区别

- voaltile关键字是线程同步的轻量级实现，所以volatile性能肯定比较好
- 多线程访问volatile关键字不会发生阻塞，而sync关键字可能会发生阻塞
- volatile保证数据可见性，不能保证原子性，sync都能保证
- volatile关键字主要用于解决变量在多个线程之间的可见性，而sync关键字解决的是多个线程之间访问资源的同步性

**wait notify signal await区别**

- 一个基于sync 一个基于lock

- 可以精准唤醒一个线程

  synchronized 方式对应的 wait, notify 不能有多个谓词条件，Lock 对应的 Condition await, signal 则可以有多个谓词条件。

  没有多个谓词条件带来的问题在于

  例如队列已满，所有的生产者现场阻塞，某个时刻消费者消费了一个元素，则需要唤醒某个生产者线程，而通过 Object notify 方式唤醒的线程不能确保一定就是一个生产者线程，因为 notify 是随机唤醒某一个正在该 synchronized 对应的锁上面通过 wait 方式阻塞的线程，如果这时正好还有消费者线程也在阻塞中，则很可能唤醒的是一个消费者线程；signalAll 更是会唤醒所有在对应锁上通过 wait 方式阻塞的线程，而不管是生产者还是消费者线程。

  与之不同的 Condition await, signal 方式则可以对应多个谓词条件（notEmpty, notFull），可以很方便的实现让生产者线程和消费者线程分别在不同的谓词条件上进行等待

#### 锁优化

- **减少锁持有时间**

  只用在有线程安全要求的程序上加锁

- **减小锁粒度**

  将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是 ConcurrentHashMap。

- **锁分离**

  最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互 斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据

- **锁粗化**

  通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步 和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。

- **锁消除**

  锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这 些对象的锁操作，多数是因为程序员编码不规范引起。

### AQS（Abstract Queued Synchronizer）

#### 原理

当某个线程请求资源时，如果资源是空闲的，就将这个请求线程设为有效的工作线程，并将这个资源设为锁定状态；如果资源已经被占用了，就将这个线程放到 CLH 队列中，**CLH（Craig, Landin, and Hagersten）队列是一个先进先出的双向队列**，它将线程封装为 CLH 队列的节点来进行锁分配。AQS 维护了一个 volatile 修饰的状态信息 state，如果 state 为 0，表示资源没有被占用，否则就表示资源被占用了，它通过 CAS 机制的原子操作来对 state 进行修改。

![image-20200826221701116](/Users/sheva/Library/Application Support/typora-user-images/image-20200826221701116.png)

#### AQS定义两种资源共享方式

- **Exclusive（独占） **

  只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤 醒。

  总结：**公平锁和非公平锁只有两处不同**： 

  1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取 到锁返回了。 
  2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个 时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状 态，如果有则不去抢锁，乖乖排到后面。

  公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻 塞队列等待唤醒。

  相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可 能会导致在阻塞队列中的线程长期处于饥饿状态。

- **Share（共享）**

   多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、 ReadWriteLock 我们都会在后面讲到。

   ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某 一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方 式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好 了。

#### CountDownLatch

##### 概念

CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使 用了 tryReleaseShared 方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。 当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过 countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得 state == 0，于是阻塞的线程便判断成功，全部往下执行。

##### 用法

1. 某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ： new CountDownLatch(n) ，每当一个任务线程执行完毕，就将计数器减 1 countdownlatch.countDown() ，当计 数器的值变为 0 时，在 CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务 时，主线程需要等待多个组件加载完毕，之后再继续执行。 
2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始 执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ： new CountDownLatch(1) ，多个线程在开始执行任务前首 先 coundownlatch.await() ，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。

##### 缺点

CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。

#### CyclicBarrier

##### 概念

CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。

CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障 （也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干 活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties) ，其参数表示屏障拦截的线程数量，每个线程 调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。

##### 与CountDownLatch的区别

- CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步 器)和 Condition 的.

- 对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可 以终止，也可以等待。

- 而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。 CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个 阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

##### 应用场景

CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行 流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计 算结果，计算出整个 Excel 的日均银行流水。

### ThreadLocal

如果想要实现每个线程都有自己的专属本地变量，JDK就提供了ThreadLocal类来解决这个问题。可以比喻成存放数据的盒子。

如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal名字的由来。可以用get()和set()方法来获取默认值或者将值改为当前线程所存的副本，从而避免的线程安全问题

最终的变量都存在ThreadLocalMap中，并不是存在ThreadLocal上，ThreadLocal可以理解为只是ThreadLocalMap的封装，传递了变量值。**map结构是为了可以每个线程关联多个变量**

#### ThreadLocal内存泄漏问题

ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来， ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存 泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set() 、 get() 、 remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal 方法后 最好手动调用 remove() 方法

#### ThreadLocal使用场景

- Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。Spring的事务主要是ThreadLocal和AOP去做实现的。

  Spring框架里面就是用的ThreadLocal来实现这种隔离，主要是在`TransactionSynchronizationManager`这个类里面，代码如下所示:

  ```java
  private static final Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);
  
   private static final ThreadLocal<Map<Object, Object>> resources =
     new NamedThreadLocal<>("Transactional resources");
  
   private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
     new NamedThreadLocal<>("Transaction synchronizations");
  
   private static final ThreadLocal<String> currentTransactionName =
     new NamedThreadLocal<>("Current transaction name");
  
  ```

  

- SimpleDataFormat中的parse方法，内部有一个Calendar对象，调用parse方法时会先调用Calendar.clear(), 然后调用Calendar.add(), 如果一个线程先调用了add(), 然后另一个线程调用了Calendar， 这时候parse会出现问题。所以使用了线程池上加上ThreadLocal包装SimpleDataFormat， 调用initialValue让每个线程有一个副本，解决线程安全问题

``` java
public class DateUtil2 {
 
    private static final String MESSAGE_FORMAT = "MM-dd HH:mm:ss.ms";
 
    private static final ThreadLocal messageFormat = new ThreadLocal(){
        protected synchronized Object initialValue() {
            return  new SimpleDateFormat(MESSAGE_FORMAT, Locale.getDefault());
        }
    };
    private static final DateFormat getDateFormat() {
      return (DateFormat) messageFormat.get();
    }
}

```

- 我在项目中存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文（Context），它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。（cookkie session）

  使用到类似责任链模式，给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，对象参数就传不进去了，所以我使用到了ThreadLocal去做了一下改造，这样只需要在调用前在ThreadLocal中设置参数，其他地方get一下就好了。

``` java
before
  
void work(User user) {
    getInfo(user);
    checkInfo(user);
    setSomeThing(user);
    log(user);
}

then
void work(User user) {
try{
   threadLocalUser.set(user);
   // 他们内部  User u = threadLocalUser.get(); 就好了
    getInfo();
    checkInfo();
    setSomeThing();
    log();
    } finally {
     threadLocalUser.remove();
    }
}
```

### CAS

#### 什么是CAS

CAS的全称为**Compare-And-Swap** ,它是一条CPU 并发原语。它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,这个过程是原子的。

CAS并发原语提现在Java语言中就是**sun.miscUnSafe类**中的各个方法。**调用UnSafe类中的CAS方法,JVM会帮我实现CAS汇编指令.这是一种完全依赖于硬件 功能,通过它实现了原子操作。**再次强调,由于CAS是一种系统原语,原语属于操作系统用于范畴,是由若干条指令组成,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许中断,也即是说**CAS是一条原子指令,不会造成所谓的数据不一致的问题。**

**CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。** 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”

通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。

类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。

#### CAS存在的问题

- **ABA问题**

  **问题描述：**当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次，而经过两次修改后，对象的值又恢复为旧值，这样当前线程无法正确判断这个对象是否修改过。

  **解决办法：**JDK1.5可以利用**AtomicStampedReference类**来解决这个问题，AtomicStampedReference内部**不仅维护了对象值，还维护了一个时间戳**。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功

- **循环等待时间过长**

  **问题描述：**自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

  **解决办法：**JVM支持处理器提供的pause指令，使得效率会有一定的提升，**pause指令有两个作用**：

  - 第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，
  - 第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

- **不能保证原子性**

  **问题描述：**当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用**锁**来保证原子性。
  **解决办法：**从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

#### concurrent包的实现

**由于java的CAS同时具有 volatile 读和volatile写的内存语义**，因此Java线程之间的通信现在有了下面四种方式：

1. A线程写volatile变量，随后B线程读这个volatile变量。
2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
3. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
4. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。

Java的CAS会使用现代处理器上提供的高效**机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作**，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，**volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石**。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：

- 首先，声明共享变量为volatile；
- 然后，使用CAS的原子条件更新来实现线程之间的同步；
- 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

### Volatile关键字

- **保证了可见性**

  直接对内存进行操作，不经过过缓存，一旦当前线程对变量写入内存后，直接通知其他线程，同一个变量失效

  **缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当CPU要对这个数据进行修改的时候，会强制重新从系统内存里把数据读到处理器缓存里。**

  所以当一个变量被volatile修饰之后，每次数据变化时，其值都会被强制刷新入主存，其他处理器是遵守了缓存一致性协议，也把这个值从主存加载到自己的缓存中，这就保证了一个volatile在并发过程中，其值在多个缓存中是可见的。

  **系统底层如何实现数据一致性**

  - MESI能解决则解决
  - 不能解决，直接锁总线（效率不高）

- **防止指令重排序**

  - CPU为了优化效率会对指令进行重新排序,这种方式在多线程并发的时候回导致安全问题.volatile在内存中加了内存屏障(storefence, loadfence)通过CPU原语实现
  
  **系统如何保证有序性**
  
  - 内存屏障 sfence mfence lfence
  - 锁总线


### JUC包

- **ConcurrentHashMap**： 

  见上

- **CopyOnWriteArrayList**： 

  为了将读取的性能发挥到极致，其内容读取时完全不用加锁的，而且读写之间也不会阻塞，只有在写入与写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。

  其中所有的可变操作（add，set）都是通过创建底层数组的新副本来实现的，当List需要被修改的时候，先不修改原有内容，而是对原有内容进行一次复制，将修改的内容写入新副本，写完之后将原来内存指针指向新的内存。

- **ConcurrentSkipListMap**： 

  跳表，参考redis的zset，内部是排序的，时间查找复杂度的O(logn)

- **CountDownLatch**：

  使用CountDownLatch(int count)构建CountDownLatch实例，将count参数赋值给内部的计数器state， 调用await()方法 阻塞该线程，并将当前线程封装加入到等待队列中，直到state等于零或者当前线程被中断；调用countDown()使state减一，如果state等于零则唤醒等待队列中的线程

## 反射的机制

**反射机制**：

反射机制是指在运行过程中，对于任意一个类可以动态的获取到这个类所有的属性和方法；并且对于任意一个对象都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能就是Java的反射机制

**获取Class的三种方法**：

- Class.forName
- 使用类的.class方法
- 使用实例对象的getClass方法

## 代理模式

### 为什么要用代理模式

假设你有一套房子要卖，一种方法是你直接去网上发布出售信息，然后直接带要买房子的人来看房子、过户等一直到房子卖出去，但是可能你很忙，你没有时间去处理这些事情，所以你可以去找中介，让中介帮你处理这些琐碎事情，中介实际上就是你的代理。本来是你要做的事情，现在中介帮助你一一处理，对于买方来说跟你直接交易跟同中介直接交易没有任何差异，买方甚至可能觉察不到你的存在，这实际上就是代理的一个最大好处。

什么时候需要代理

1. 可能在外地上班，买房的人没办法跟你直接交易。客户端无法操作实际对象，可能是你需要调用的对象在另一台机器上，需要跨网络，如果你处理，需要通过网络传输。这时候就直接在客户端创建一个代理，客户端像调用本地对象一样调用代理。
2. 你可能不知道该怎么做。对应到我们程序设计的时候就是：除了当前类能够提供的功能外，我们还需要补充一些其他功能。最容易想到的情况就是权限过滤，我有一个类做某项业务，但是由于安全原因只有某些用户才可以调用这个类，此时我们就可以做一个该类的代理类，要求所有请求必须通过该代理类，由该代理类做权限判断，如果安全则调用实际类的业务开始处理。可能有人说为什么我要多加个代理类？我只需要在原来类的方法里面加上权限过滤不就完了吗？在程序设计中有一个类的单一性原则问题，这个原则很简单，就是每个类的功能尽可能单一。为什么要单一，因为只有功能单一这个类被改动的可能性才会最小，就拿刚才的例子来说，如果你将权限判断放在当前类里面，当前这个类就既要负责自己本身业务逻辑、又要负责权限判断，那么就有两个导致该类变化的原因，现在如果权限规则一旦变化，这个类就必需得改，显然这不是一个好的设计。

### 静态代理

事先确定了代理者与被代理者之间的关系，也就是说，若代理类在程序运行前就已经存在了，这种情况就叫静态代理

**优点：**

- 客户端不必知道实现类如何，只需要调用代理类即可

**缺点：**

- 代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。但这样出现了大量的代码重复。如果接口新增一个方法，所有实现类都要实现这个方法，所有代理类也要实现这个方法
- 代理对象只服务于一种类型的对象。如果要服务多类型的对象，那就要对每种对象都进行代理。

### 动态代理

代理类在程序运行时创建的代理方式。也就是说，代理类并不是在Java代码中进行定义的，而是在运行期间根据我们在Java代码中的“指示”动态生成的。（**就静态代理而言，在委托类特别多的应用场景，就要相应的添加许多的代理类，这显然增加了应用程序的复杂度，而使用动态代理就可以减少代理类的数量，相对降低了应用程序的复杂度**。）

### JDK动态代理与cglib实现的区别：

- java动态代理利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler处理
- cglib动态代理利用asm开源包，对代理类的class文件加载进来，通过修改字节码生成子类进行处理
- JDK动态代理只能对实现了接口的类生成代理，而不能针对类
- cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以最好不要声明成final

## 序列化与反序列化

### 为什么要序列化

如上所述，读写对象会有什么问题呢？比如：我要将对象写入一个磁盘文件而后再将其读出来会有什么问题吗？别急，其中一个最大的问题就是对象引用！

举个例子来说：假如我有两个类，分别是A和B，B类中含有一个指向A类对象的引用，现在我们对两个类进行实例化{ A a = new A(); B b = new B(); }。这时在内存中实际上分配了两个空间，一个存储对象a，一个存储对象b。接下来我们想将它们写入到磁盘的一个文件中去，就在写入文件时出现了问题！因为对象b包含对对象a的引用，所以系统会自动的将a的数据复制一份到b中，这样的话当我们从文件中恢复对象时(也就是重新加载到内存中)时，内存分配了三个空间，而对象a同时在内存中存在两份，想一想后果吧，如果我想修改对象a的数据的话，那不是还要搜索它的每一份拷贝来达到对象数据的一致性，这不是我们所希望的！
**以下序列化机制的解决方案：**
1.保存到磁盘的所有对象都获得一个序列号(1, 2, 3等等)

2.当要保存一个对象时，先检查该对象是否被保存了

3.如果以前保存过，只需写入"与已经保存的具有序列号x的对象相同"的标记，否则，保存该对象通过以上的步骤序列化机制解决了对象引用的问题！

### 序列化与反序列化的概念

- 序列化是指将对象转换为字节序列的过程，而反序列化是将字节序列转换为对象的过程
- Java对象实例化是通过实现Serializable接口的对象转换成一个字节序列，能够通过网络传输、文件存储等方式传输，传输过程中不必担心数据在不同机器，不同环境下发生改变，也不必关心字节的顺序或者其他任何细节，并能够在以后将这个字节序列完全恢复为原来的对象
- 对于不想被序列化的变量，用transient关键字进行修饰，其作用是：阻止实例中哪些用次关键字修饰的变量的序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复，该关键字只能修饰变量，不能修饰类和方法

## 深拷贝与浅拷贝

- **深拷贝**： 对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制源对象的内容
- **浅拷贝**： 对基本数据类型进行值传递，对引用数据类型进行引用传递般的传递。

![image-20200813143604181](/Users/sheva/Library/Application Support/typora-user-images/image-20200813143604181.png)

## 单例模式

``` java
//懒汉式单例模式
public class Singleton{
  private volatile static Singleton INSTANCE;
  //私有化构造方法
  private Singleton(){}
  public static Singleton getInstance(){
    //双重锁
    if(null == INSTANCE){
      sychronized(Singleton.class){
        if(null == INSTANCE){
          INSTANCE = new Singleton();
        }
      }
    }
    return INSTANCE;
  }
}
```

```java
//饿汉式单例模式
public class Singleton{
  private static Singleton INSTANCE = new Singleton();
  private Singleton(){}
  public static Singleton getInstance(){
    return INSTANCE;
  }
}
```

```java
//静态内部类，线程安全，且可以达到延迟加载的目的
public class Singleton{
  private Singleton(){}
  private static class SingletonHolder(){
    private static Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance(){
    return SingletonHolder.INSTANCE;
  }
}
```

## 倒排索引

讲倒排索引之前先讲正牌索引，意思就是我们的所有文档都有唯一一个文档id，根据文档里的内容算出每个文档中关键字的内容和次数，类似于通过key去找value的形式，如果正牌索引，我们每次寻找关键字查询，就得搜索所有的文档去看是否有这个关键字，这样查询效率太慢了。
于是有了倒排索引，是通过关键字去查文档，我们建立一个索引库，里面的key是关键字，value是每个文档的id，倒排在构建索引的时候较为耗时且维护成本较高，但是搜索耗时短，所以我们可以定时去更新索引库。
查询出来的文档可以通过一个打分算法来进行排序。

## 线程

### 线程的生命周期

- **新建状态**

  当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配 内存，并初始化其成员变量的值

- **就绪状态**

  当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和 程序计数器，等待调度运行。

- **运行状态**

  如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状 态。

- **阻塞状态**

  阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。 直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状 态。

  阻塞的情况分三种： 等待阻塞（o.wait->等待队列）： 运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中。 同步阻塞(lock->锁池) 运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线 程放入锁池(lock pool)中。 其他阻塞(sleep/join) 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。

- **线程死亡**

  线程会以下面三种方式结束，结束后就是死亡状态。 

  正常结束 

  1. run()或 call()方法执行完成，线程正常结束。 异常结束 

  2. 线程抛出一个未捕获的 Exception 或 Error。 调用 stop 
  3. 直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用

### 终止线程的四种方式

- **正常运行结束**

- **使用退出标志位退出线程**

  一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的 运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如： 最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while 循环是否退出，代码示例：

  ```java
  public class ThreadSafe extends Thread {
   public volatile boolean exit = false;
   public void run() {
   while (!exit){
   //do something
   }
   }
  }
  ```

- **Interrupt方法结束线程**

  线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。 阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让 我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实 际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正 常结束 run 方法。

  线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。

- **stop方法终止线程**

  不安全，不推荐使用，因为使用后会强制释放子线程的所有锁，会出现数据不一致性的情况

### sleep与wait的区别

- 对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。
- sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然 保持者，当指定的时间到了又会自动恢复运行状态。
- 在调用 sleep()方法的过程中，线程不会释放对象锁。
- 而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此 对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

### start与run的区别

- start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕， 可以直接继续执行下面的代码。
- 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运 行。
- 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运 行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。

### 线程间通信

- **thread.join()方法**

​       假设有A、B两个线程，在B线程的run()方法中调用A.join()方法会让 B一直等待直到 A 运行完毕才继续运行。

- **object.wait()和object.notify()**

  定义全局锁Object lock = new Object();

  假设有A、B两个线程，在A线程中执行完想要其执行的部分后调用lock.wait()。

  B线程在执行完想要其执行的部分后调用lock.notify()，交出锁的控制权。

  当然，A线程和B线程的run()方法内容是在synchronized(lock)下的。

- **await signal**

  java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

  相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

  使用 Lock 来获取一个 Condition 对象。

- **CountDownLatch**

  应用场景：多个线程同时运行完成后目标线程T开始运行，即一个线程等待多个线程的场景

  首先创建一个计数器，CountdownLatch countDownLatch = new CountDownLatch(3);

  表示有3个线程需要同步运行

  在目标线程里调用countDownLatch.await() 方法，进入等待状态，直到计数值变成 0；

  在同步运行的线程中，结束前调用countDownLatch.countDown()方法，该方法会将计数值减小1；

  当计数值变成 0 时，目标线程里的countDownLatch.await() 立即退出，继续执行其代码。

- **CyclicBarrier**

  应用场景：实现线程间互相等待再一起执行

  首先创建一个CyclicBarrier对象

  CyclicBarrier cyclicBarrier = new CyclicBarrier(3);

  表示有3个线程需要同步运行

  当各个线程准备好执行时，调用cyclicBarrier.await()函数，当3个线程都调用了这个函数后，3个线程开始同步运行。

### 多线程应用场景

- **多线程处理后台任务**

  一般来说，我们需要在后台处理的任务，通常会使用定时器来开启后台线程处理，比如有些数据表的状态我需要定时去修改、我们搜索引擎里面的数据需要定时去采集、定时生成统计信息、定时清理上传的垃圾文件等。

- **多线程异步处理任务**

  当我们需要处理一个耗时操作并且不要立刻知道处理结果时，我们可以开启后台线程异步处理该耗时操作，这样可以提高用户体验。比如我之前做的一个项目需要上传简历附件，后台需要对简历附件进行解析，保存到数据表中，因为涉及多种格式的处理，所以我们开启多线程异步处理此操作，这样用户就不用等到我们的简历解析完就能看到服务端的响应了。再比如用户下载简历时，我们需要将数据表中的数据生成简历附件并且通过邮件发送到用户邮箱，该操作也可以开启多线程异步处理。

- **多线程分布式计算**

  当我们处理一个比较大的耗时任务时，我们可以将该任务切割成多个小的任务，然后开启多个线程同时处理这些小的任务，切割的数量一般根据我们服务器CPU的核数，合理利用多核CPU的优势。比如下载操作可以使用多线程下载提高下载速度；清理文件时，开启多个线程，按目录并行处理等等。

## 线程池

### 什么是线程池

线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行由线程池来进行管理。

**线程池使用**

```java
ExecutorService cachePool = Executors.newCachedThreadPool();
cachePool.execute(getThread(i));
```

### 工作原理

![image-20200824170014769](/Users/sheva/Library/Application Support/typora-user-images/image-20200824170014769.png)

### 为什么要使用线程池

**创建和销毁线程的开销是比较大的，这些时间可能比处理业务的时间还长。**这样繁琐的创建线程和销毁线程，比较消耗系统资源我们可以把创建和销毁线程的过程去掉。

在实际使用中，线程是很占用系统资源的，如果对线程的管理不当很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池有**以下好处（优点）**

- 使用线程池可以重复利用已有的线程继续执行，**避免线程在创建和销毁时造成的损耗**
  - 为线程堆栈分配和初始化大量内存块
  - 必须进行系统调用，用户态 ---> 内核态的转换（要在OS中创建、注册本机线程）
  - 描述符需要创建，初始化并添加到JVM内部数据结构中
- 由于没有线程创建和销毁的消耗，可以提高线程响应速度
- 通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行的线程数量和大小

### 线程池的组成

1. 线程池管理器：用于创建并管理线程池 
2. 工作线程：线程池中的线程 
3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行
 4. 任务队列：用于存放待处理的任务，提供一种缓冲机制

### 线程池的生命周期

- **RUNNING**: 能接受新提交的任务，并且也能处理阻塞队列中的任务
- **SHUTDOWN**： 关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保持的任务
- **STOP**：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程（奥力阻止）
- **TIDYING**：如果所有的任务都已终止了，workerCount（有效线程数）为0，线程池进入该状态后会调用terminated()方法进入TERMINATED状态。
- **TERMINATED**： 在terminated()方法执行完后进入该状态，默认terminated()方法中什么也没有做

### 线程池分类以及使用场景

#### ThreadPoolExecutor

- **newCachedThreadPool**（推荐使用）

  创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程（使用了SynchronousQueue）

  ```java
  ExecutorService executorService = Executors.newCachedThreadPool();
  ```

  - **特点**： **核心线程数为0**；**最大线程数为MAX_VALUE**；**阻塞队列为SynchronousQueue**，**非核心线程空闲存活时间为60s**
  - **使用场景**: 一个可以无限扩大的线程池,比较适合处理执行时间较小，并发量大的任务

- **newFixedThreadPool**

  创建一个固定数量的线程池，可以控制线程最大并发数，超出的线程在队列中等待（使用了LinkedBlockingQueue）

  ```java
  //需要指定线程个数 nThread
  ExecutorService executorService = Executors.newFixedThreadPool(5);
  ```

  - **特点**：**核心线程数与最大线程数一样；没有所谓的非空闲时间，keeyAliveTime为0；阻塞队列为无界队列LinkedBlockingQueue**

  - **使用场景**： 用于已知并发压力的情况下，对线程数量进行限制
  - **内存飙升问题**： 使用了无界队列LinkedBlockingQueue，如果一个线程获取一个任务后，执行时间比较长，则会导致队列的任务越来越多，导致机器内存使用不停飙升，最终OOM

- **newSingleThreadExecutor**

  创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，核心线程数与最大线程数均为1，空闲线程存活时间为0ms，保证所有任务按照指定顺序执行（可以在线程死后重新启动一个线程替代原来的线程重新执行下去）

  ``` java
  ExecutorService executorService = Executors.newSingleThreadExecutor();
  ```

  - **特点**： **核心线程数为1； 最大线程数也为1**；**阻塞队列为LinkedBlockingQueue**；**keepAliveTime为0**

  - **使用场景**：可以用于需要保证顺序执行的场景，并且只有一个线程在执行，串行化任务

#### ScheduledThreadPoolExecutor

- **newScheduledThreadPool**

  创建一个定长线程池，支持定时以及周期性任务执行（使用了DelayQueue）

  ```java
//需要指定corePoolSize
  ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3);
  //可以指定延迟时间
  scheduledExecutorService.scheduled(new Runnable(){...});
  ```
  
  - **特点**： **最大线程数为MAX_VALUE； 阻塞队列是DelayedWorkQueue，keepAliveTime为0，scheduleAtFixedRate（）按照某种速率周期执行，scheduleWithFixedDelay（）在某个延迟后执行**
  - **使用场景**: 可以**延时启动**,定时启动的线程池,适用于需要多个后台线程执行周期任务的场景
  
- **newSingleThreadScheduledExecutor**

#### ForkJoinPool

- **newWorkStealingPool**

  ```java
  //设置并行级别 parallelism
  ExecutorService m = Executors.newWorkStealingPool(8);
  ```

### 线程池中的重要参数

```java
//自定义线程池参数
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler, handler)
```

- **corePoolSize**： 线程池中的核心线程数量，这几个核心线程在没有使用的时候也不会被回收

- **maximumPoolSize**： 线程池中可以容纳的最大线程数量

- **keepAliveTime**： 就是线程池中除了核心线程之外的其他最长可以保留的时间，因为在线程池中，除了核心线程即时在无任务的情况下也不会被回收，其他线程都是有存活时间的，意思就是非核心线程可以保留的最长空闲时间

- **unit**： 线程空闲存活时间单位

- **workQueue**： 存放任务的阻塞队列

- **threadFactory**： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字

- **handler**： 线程池的饱和策略事件，拒绝策略,主要有四种类型

  - **AbortPolicy策略**：该策略会直接抛出异常,阻止系统正常工作
  - **DiscardPolicy策略**：直接丢弃无法处理的任务，但是不会抛出异常
  - **DiscardOlddestPolicy策略**： 丢弃最老的一个请求，也就是队列最前面的任务，,并且重新尝试执行任务
  - **CallerRunsPolicy策略**： 只要线程池未关闭，则在调用者线程中直接执行新任务，这会导致主线程提交线程速度变慢

  除了JDK提供了四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，直接去实现RejectedExecutionHandler接口即可

### 线程池的工作队列

- **ArrayBlockingQueue**： 有界队列，是一个用数组实现的有界阻塞队列，按照FIFO排序。在生产者和消费者获取数据，都是用同一个锁对象
- **LinkedBlockingQueue**： 可设置容量队列，基于链表结构的实现，按照FIFO排序，容量可以进行设置，如果不设置的话将会是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，其之所以能够高效的处理并发数据是因为对于生产者和消费者分别采用了独立的锁机制来控制同步，意味着在高并发下可以高效的处理队列中的数据
- **DelayQueue**： 延迟队列是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。其中的元素只有当指定的延迟时间到了，才能够从队列中获取元素。生产者不会被阻塞，消费者才会被阻塞。使用场景比较少
- **PriorityBlockingQueue**： 优先级队列，具有优先级的无界阻塞队列。生产者不会被素色，消费者会被阻塞。
- **SynchronousQueue**： 同步队列是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue。一中无缓冲的等待队列。

**ArrayBlockinQueue与LinkedBlockingQueue的区别：**

- **队列中锁的实现不同**

  前者实现的队列中的锁是没有分离的，生产者和消费者用的是同一个锁；后者实现的队列中的锁时分离的，即生产者用putLock，消费者用takeLock

- **队列大小初始化方式不同**

  前者实现的队列中必须指定队列的大小；后者实心的队列中可以不指定队列的大小，默认是Integer.MAX_VALUE

### 为什么不建议使用Executors静态工厂构造线程池

线程池不允许使用Executors去创建，而是通过ThreadPoolExecutors的方式，这样的处理方式让写的同学能够更加明确线程池的运行规则，规避资源耗尽的风险

**Executors返回的线程池对象的弊端如下：**

1. FixedThreadPool和SingleThreadPool

   允许请求的队列（LinkedBlockingQueue）长度为Integer.MAX_VALUE，可能会导致大量请求导致OOM

2. CachedThreadPool和ScheduledThreadPool

   允许创建的线程数量为Integer.MAX_VALUE,可能会导致OOM

正确的方式（通过ThreadPoolExecutors构造函数来自己创建线程池，创建的同事给BlockingQueue指定容量即可）

```java
private static ExecutorService executor = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue(10));
```

### execute与submit的区别

- execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能好很多
- submit返回一个future对象，如果想知道线程结果就使用submit提交，而且他能在主线程中通过Future的get方法捕获线程的异常

### 线程池的关闭

- shutdownNow：对于正在执行的任务全部发出Interrupt()， 对于还未开始执行的任务全部取消，并且返回还没有开始的任务列表
- shutdown：发出任务后，线程池不再接受新的任务，但是不会强制停止已经提交或者正在执行中的任务

# 操作系统

## 什么是操作系统

- 是**管理计算机硬件与软件资源的程序**，是计算机系统的内核与基石
- **本质上是运行在计算机上的软件程序**
- 操作系统为用户提供了一个与系统交互的操作界面
- 操作系统分为内核与外壳

## 什么是系统调用

- 用户态： 用户态运行的进程可以访问用户程序的数据
- 系统态：系统态运行的进程几乎可以访问计算机的任何资源，不受任何限制

凡是与系统态级别有关的操作，都必须通过系统调用的方式向操作系统提出服务请求，并且由操作系统代为完成，大致分为以下几类

- **设备管理**。完成设备的请求与释放
- **文件管理**。完成文件的读写创建删除操作
- **进程控制**。完成进程的创建 撤销 阻塞已经唤醒
- **进程通信**。完成进程之间的相互通信
- **内存管理**。完成内存分配回收等功能

## 进程与线程

### 进程与线程的区别

- 进程是程序运行的基本单位
- 线程是进程划分为更小的运行单位，一个进程可以产生多个线程。而且**进程之间是相互独立的**，而线程之间可能会互相影响。

### 进程的生命周期

创建状态（new）  运行状态（running）  阻塞状态（waiting）  结束状态（terminated）

### 线程的生命周期

- **NEW** ：初始状态，线程被构建，但是还没有调用start()方法
- **RUNNABLE** ： 运行状态 java线程将操作系统中的就绪与运行都定义为运行状态
- **BLOCKED**： 阻塞状态，表示线程阻塞

**WAITING**： 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程的一些操作

- **TIME_WAIT**： 超时等待状态，该状态不同于WAITING，他是可以在指定的时间内自行返回的
- **TERMINATED**: 终止状态,表示当前线程已经执行完毕

### 进程间通信方式

- **管道/匿名管道（Pipes）**: 具有亲缘关系的父子进程之间或者兄弟进程之间的通信
- **有名管道（Nameds Pipes）**: 严格遵循FIFO。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信
- **信号（Signal）**： 是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
- **消息队列（Message Queuing）**：消息队列是消息的链表，具有特殊的格式。严格遵循FIFO。与管道不同的是消息队里了存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取，比FIFO更具有优势。该方法客服了信号承载信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷。
- **信号量（Semaphores）**: 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并且避免竞争条件
- **共享内存（Shared memory）**： 使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作
- **套接字（Socket）**： 此方法主要用于在客户端和服务器之间通过网络进行传输。套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点。

### 进程间调度算法

- **先到先服务（FCFS）**： 从就绪队列中选择最先加入队列的进程并为之分配资源
- **短作业有限（SJF）**： 从就绪队列中选出一个估计事件最短的为期分配资源
- **时间片轮转**：是最古老，最简单，最公平且使用最广泛的算法，又称为RR（Round Robin）调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间
- **多级反馈队列调度**： 多级反馈队列调度算法既能使高优先级的作业能够得到相应又能使短作业迅速完成，它目前被认为是一种较好的进程调度算法，UNIX便是采用该算法
- **优先级调度**： 为每个流程分配优先级，首先执行具有最高优先级的进程，以此类推。

### 线程间同步的方式

- **互斥量（Mutex）**： 采用互斥对象机制，只有拥有胡吃对象的线程才可以访问公共资源。例如Synchronize与Lock都是这种机制
- **信号量（Semphares）**： 他允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问次资源的最大线程数量
- **事件（Event)**： wait、notify 通过通知操作的方式保持线程同步

### 死锁

#### 产生条件

- **互斥条件**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
- **不剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
- **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有，如图2-15所示。

#### 预防

我们可以通过破坏死锁产生的**4个必要条件**来预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。

- **破坏互斥条件**：无法破坏
- **破坏请求与保持条件**：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，就主动释放它占有的所有资源
- **破坏循环等待条件**：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。（靠按序申请资源来预防。按照某一顺序申请资源，释放资源则反序释放。）

#### 避免

系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 
如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。

- **加锁顺序**

  确保所有的线程都是按照相同的顺序获得的锁，那么死锁就不会发生

- **加锁时限**

  在尝试获取锁的时候加一个超时时间。若超过了这个时限，则该线程放弃对锁的请求。若一个线程没有在给定的时限内成功获得所需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间重试

- **死锁检测**

  主要针对那些不可能时限按序加锁并且锁超时也不可行的场景

  每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

  当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

  那么当检测出死锁时，这些线程该做些什么呢？

  一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。

  一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。

**银行家算法**

银行家算法基本思想： 允许进程动态地申请资源，系统在每次实施资源分配之前，先计算资源分配的安全性，若此次资源分配安全（即资源分配后，系统能按某种顺序来为每个进程分配其所需的资源，使每个进程都可以顺利地完成），便将资源分配给进程，否则不分配资源，让进程等待。

## IO模型

### 阻塞IO模型

最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就 绪，就会一直阻塞在 read 方法。

### 非阻塞IO模型

当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：

```java
while(true){
data = socket.read();
if(data!= error){
处理数据
break;
}
}
```

但是对于非阻塞 IO 就有一个非常严重的问题，**在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。**

### 多路复用IO模型

在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真 正调用实际的 IO 读写操作。

在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。**多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连 接数比较多的情况。**

另外多路复用 IO 为何比非阻塞 IO 模型的效率高是**因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。**

### 信号驱动IO模型

在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。

### 异步IO模型

在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说**用户线程完全不需要实际的整个 IO 操作是如何 进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接 去使用数据了。** 

也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完 成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的 读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据 已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号 表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。

### BIO NIO AIO

- **BIO(Blocking I/O)**： 同步阻塞I/O模式，数据的读取与写入必须阻塞在一个线程内等待完成，在活动连接数不是特别高的情况下这种模型是不错的，可以让每一个连接专注于自己的I/O并且编程简单，但是在高并发情况下无能为力
- **NIO(Non-Blocking/NEW I/O)**： 同步非阻塞式I/O模型，提供了Channel， Selector， Buffer等抽象。它是**面向缓冲**的，基于通道的I/O操作方法。通常来说NIO中的IO都是从Channel开始的，创建一个缓冲区，然后请求通道进行读取；创建一个缓冲区，填充数据，并要求通道写入数据（面向缓冲区 Buffer Oriented）
- **AIO(Asynchronous I/O)**： AIO也就是NIO2，是异步非阻塞的IO模型。异步IO是基于事件和回调机制进行实现的，也就是应用操作之后直接返回，不会阻塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作，目前应用较少。

### NIO

NIO 主要有三大核心部分：**Channel(通道)，Buffer(缓冲区), Selector(选择器)**。传统 IO 基于字节流和字 符流进行操作，而 **NIO 基于 Channel 和 Buffer(缓冲区)进行操作**，数据总是**从通道读取到缓冲区** 中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开， 数据到达）。因此，单个线程可以监听多个数据通道。NIO 和传统 IO 之间第一个最大的区别是，**IO 是面向流的，NIO 是面向缓冲区的。**

#### 非阻塞

IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有 一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可 用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以 继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它 完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上 执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

#### Channel（通道）

Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向 的，既可以用来进行读操作，又可以用来进行写操作。 

NIO 中的 Channel 的主要实现有： 1. FileChannel 2. DatagramChannel 3. SocketChannel 4. ServerSocketChannel 这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。 下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。

#### Buffer（缓冲区）

Buffer，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。

![image-20200816195853857](/Users/sheva/Library/Application Support/typora-user-images/image-20200816195853857.png)

在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer

#### Selector（选择器）

Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。

## 内存管理机制

简单分为**连续分配管理与非连续分配管理**。连续分配管理是指为一个用户程序分配一个连续的内存空间，常见的如快式管理。非连续常见的有页式管理，段式管理

- **块式管理**

  远古时期的内存管理方式。将内存分成几个固定大小的块，每个块中只包含一个进程。但是由于大小固定，如果程序只需要很小的一块内存的话，内存就被浪费了

- **页式管理**

  把主存分为大小相等且固定的一页一页的形式，相比于块式管理，划分力度更大，提高了内存利用率，减少了碎片。通过页表对应逻辑地址和物理地址（页的大小是由操作系统决定的，是固定的）

- **段式管理**

  页式管理中的页并没有实际意义，段式管理把主存分为一段一段，每一段的空间比一页小得多。但是段式具有实际意义的，每个段定义了一组逻辑信息，例如主程序段MAIN，子程序段X，数据段D,以及栈段S。段式管理通过段表对应逻辑地址和物理地址

- **段页式管理**

  结合了段式与页式的优点，先将内存分成若干段，每个段再分成若干页

## 快表与多级页表

为了解决两个问题：

1. 虚拟地址到物理地址的转换快
2. 虚拟地址空间大，页表也会很大的问题

- 快表

  可以理解为时一中页数的高速缓冲Cache，类似于redis缓存的原理先查快表，再查页表

- 多级页表

  利用局部性原理，动态创建二级页表，用来节省空间

  为了避免全部页表一直放在内存中导致占用空间的问题，设计了多级页表。典型的时间换空间。

## 为什么需要虚拟地址

- CPU通过**MMU（Memory Management Unit）**将虚拟地址翻译为物理地址
- 直接操作物理内存不安全，容易造成系统崩溃
- 想要同时运行多个程序困难，通过虚拟地址，可以用一系列相邻的虚拟地址来访问不相邻的物理内存；而且不同进程见的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存

## 虚拟内存

- 虚拟内存是内存管理的一个技术，重要意义是定义了一个连续的虚拟地址空间，并且把内存扩展到了硬盘空间
- 他让每个进程产生了一中自己再独享主存的错觉

## 局部性原理

- 时间局部性：一个指令被执行到时，不久后还会被执行（由于程序的循环操作）
- 空间局部性：一旦程序访问某个存储单元时，其附近的单元在不久后也将被访问到（因为指令的顺序执行，数组等数据的聚集存放）

## 虚拟内存技术的实现

虚拟内存的实现需要建立在离散分配的**内存管理**方式的基础上

- 请求分页式存储
- 请求分段式存储
- 请求段页式存储

## 页面置换算法

**缺页中断**：发现要访问的页不再主存，需要操作系统将其调入主存后再进行访问

- FIFO：先进先出
- LRU： 最近最久未使用
- LFU： 最近最少使用
- OPT算法：最佳页面置换算法。淘汰的是以后用不使用的，或者是最长时间内不再被访问的页面，但是算法无法实现

## Linux相关

### 文件目录

- /bin：存放二进制可执行文件（ls cat mkdir等） 常用命令一般都在这里
- /etc：存放系统管理与配置文件
- /home：存放所有用户文件的根目录
- /usr：存放系统应用程序
- /opt：额外安装的可选应用程序包就可以安装在这
- /proc：虚拟文件系统目录，是系统内存的映射，一般可以直接访问这个目录来获取系统信息
- /root：超级用户的主目录
- /sbin：存放二进制可执行文件，只有root才能访问。存放的是系统管理员使用的系统级别命令和程序  例如ifconfig
- /dev：存放设备文件
- /mnt：系统管理员安装临时文件系统的安装点，提供这个目录是让用户临时挂在其他文件系统
- /boot：存放用于系统引导时使用的各种文件
- /lib：存放系统运行相关的库文件
- /tmp：存放临时文件，是公用的临时文件存储点
- /var：存放运行时需要改变数据的文件，也是某些大文件的溢出区，比如日志文件等等
- /lost+found：平常是空的，*系统非正常关机而留下的无家可归的文件就在这*

### 常用指令

**如何查看端口被占用情况**

```shell
lsof -i : 端口号
netstat -anp | grep
```

**查看进程**

```shell
ps -aux | grep 进程名
```

**kill命令用于终止进程**

```shell
kill -9 [PID]
```

**查看日志的指定行数**

tail cat head 命令

```shell
1. 显示最后10行 tail -n 10
2. 从第10行显示到最后 tail -n +10
3. 显示前面10行 head -n 10
4. 从第10行开始显示15行  cat access.log | tail -n +10 | head -n 15
```

**查看linux目录剩余空间大小**

```shell
1. 查看包含给定文件磁盘空间使用情况 df /home
2. 以人们易读的方式显示 df -hl
3. du显示目录或文件大小  df显示每个<文件>所在的文件系统的信息，默认是显示所有文件系统  
```

**文件权限**

文件基本权限有9个 对应三种身份 owner group others 数字化 **r=4 w=2 x=1**对应进行相关操作

**查看资源占用情况**

```shell
top [参数]
```

# 计算机网络

## OSI七层协议

OSI的七层由低到高依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层，下三层（物理层、数据链路层、网络层）面向数据通信，而上三层（会话层、表示层、应用层）则面向资源子网，而传输层则是七层中最为重要的一层。它位于上层和下层中间，起承上启下的作用。

- **物理层**（中继器  集线器  网线 hub   基本单位bit）
  为数据链路层提供物理连接，实现比特流的透明传输，所传输数据的单位是比特，该层定义了通信设备与传输线接口硬件的电气、机械以及功能和过程的特性。
- **数据链路层**（网卡  网桥  交换机  基本单位 frame帧）
  在通信的实体之间建立数据链路连接，传送以帧为单位的数据，通过检查发生在连接通信系统间传送路上的比特错误并进行恢复，确保比特序列组成为数据流准确无误地传送给对方的系统。数据链路层在相邻的节点之间实现透明的高可靠性传输。
- **网络层**（路由器  防火墙  多层交换机   基本单位数据包packet）
  解决多节点传送时的路由选择、拥挤控制及网络互连等，控制分组传送系统的操作，它的特性对高层是透明的，同时，根据传输层的要求选择服务质量，并向传输层报告未恢复的差错。
- **传输层**（进程和端口）
  为两个端系统（源站和目标站）的会话层之间建立一条传输连接，可靠、透明地传送报文，执行端一端差错控制、顺序和流量控制、管理多路复用等。本层提供建立、维护和拆除传送连接的功能，并保证网络连接的质量。它向高层屏蔽了下层数据通信的细节，因而是OSI网络参考模型中最需要的一层。
- **会话层**（建立回话  session认证   断点续传）
  不参与具体的数据传输，但对数据传输的同步进行管理。它主要负责提供两个进程之间建立、维护和结束会话连接功能，同时要对进程中必要的信息传送方式、进程间的同步以及重新同步进行管理。
- **表示层**（编码方式   图像编解码）
  解决在两个通信系统中交换信息时不同数据格式的编码之间的转换，语法选择，数据加密与解密及文本压缩等。
- **应用层**（应用程序   FTP   SMTP   HTTP）
  负责向用户提供各种网络应用服务，如文件传输、电子邮件、远程访问等。把进程中于对方进程通信的部分放入应用实体中，同时，对各种业务内容的通信功能进行管理。

## TCP/IP体系相关问题

- **应用层**

  任务是通过应用进程间的交互来完成特定的网络应用。应用层协议定义的是应用进程间的通信和交互的规则。例如 **HTTP协议 SMTP协议 域名系统DNS  FTP文件传输协议** 

- **表示层**

  表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

- **会话层**

  会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   

- **运输层**

  运输层主要任务就是**负责向两台主机进程之间的通信提供通用的数据传输服务**，主要有以下两种协议

  - **TCP（Transmission Control Protocol）** 提供面向连接的，可靠的数据传输服务。
  - **UDP（User Datagram Protocol）** 提供无连接的，尽最大努力的数据传输服务

- **网络层**

  在计算机网络中进行通信的两个计算机之间可能会经过很多数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据即时传输  主要有**IP协议 ICMP/IGMP/ARP/RARP**

- **数据链路层**

  通常称为链路层。两台主机之间的数据传输，总在一段一段的链路上传送，这就需要专门的链路传输协议 （**MAC地址 PPP等等**）

- **物理层**

  物理层上传输的数据单位是**比特**。 物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽可能屏蔽掉传输介质和物理设备的差异

### 三次握手

**tcp的几种状态：**

SYN表示建立连接

FIN表示关闭连接

ACK表示响应

PSH表示有数据传输

RST表示连接重置

 **三次握手的过程**

- 第一次握手 Client将SYN置为1， 随机产生一个值seq=J，并将该数据包发送给Server， Client进入syn_sent状态，等待Server确认
- 第二次握手 Server接收到数据包后根据SYN=1判断客户端要建立连接，Server将SYN与ACK置为1， ack=J+1， 随机产生一个seq=K，并将数据包发送回客户端以确认连接请求，Server进入syn_rcvd状态
- 第三次握手 Client确认后，检查ack=J+1， ACK是否为1， 如果正确，则将标志位ACK设置为1，ack=K+1， 并将该数据包发送给Server，Server检查ack是否为K+1， ACK是否为1， 如果正确则连接建立成功，Client与Server都进入established状态，完成三次握手，随后进行传输数据

**为什么要三次握手**

主要是为了防止已经失效的请求报文突然又传输到了服务器，从而产生错误

如果只有两次握手，由于网络延迟等原因，第一次握手被阻塞在网络中，第二次建立连接之后，第一次请求被服务器收到，又再次连接上了，造成了不必要的资源浪费

![image-20200814135148341](/Users/sheva/Library/Application Support/typora-user-images/image-20200814135148341.png)

### 四次挥手

- 第一次挥手  Client发送一个FIN， 用来关闭Client到Server的数据传送，Client进入fin_wait_1状态
- 第二次挥手 Server收到FIN之后，发送一个ACK给Client，确认序号为收到的序号+1， Server进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但如果服务器要发送数据，客户端还是要接收
- 第三次挥手 Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入Last_ack状态
- 第四次挥手 Client收到FIN之后，Client进入Time_wait状态，接着发送一个ACK给Server，确认序号为收到的序号+1， Server进入Closed状态，完成四次挥手

![image-20200814135133897](/Users/sheva/Library/Application Support/typora-user-images/image-20200814135133897.png)

**为什么要四次挥手  为什么不是三次挥手**  

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。**TCP是全双工模式**，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。（**确保双方都将不再发送数据**）

因为在客户端第一次挥手时，服务端可能还在发送数据，所以第二次挥手和第三次挥手不能够合并

**为什么客户端最后要等待2MSL时间**

MSL（Maximum Segment Lifetime）， TCP允许不同的实现可以设置不同的MSL值。

第一个MSL 保证客户端最后发送的ACK可以顺利到达服务器，因为这个报文可能丢失。第二个MSL是为了保证万一服务器传输的数据没到，则客户端可以收到重传的报文

### TCP协议 UDP协议的区别

- UDP在传输数据之前不需要建立连接，远程主机在收到UDP报文之后，不需要给出任何确认。虽然UDP不提供可靠交付，但是在某些情况下UDP的确是一种最有效的工作方式（一般用于即时通信）

  无连接，不可靠，通过数据报文发送，传输效率快，所需资源少，在要求通信速度高的情况下可以使用

- TCP提供面向连接的服务，在传输数据之前必须先建立连接，数据传送结束后需要释放连接。TCP提供广播或多播服务。由于TCP提供可靠的，面向连接的服务（可靠体现在三次握手，而且在数据传递时，有确认，窗口，重传，拥塞控制等机制），在数据传输完成后还会断开连接，但是这也难以避免的增加了许多开销，如确认，流量控制，计时器以及连接管理等。比较占用处理机资源。TCP一般用于文件传输，发送和接收邮件，远程登录等场景

### TCP如何保证可靠传输

- 应用程序被分割成TCP认为最合适发送的数据块
- TCP给每个包进行编号，接收方对数据包进行排序，把有序的数据传给应用层
- **校验和**：TCP将保持首部和数据的校验和。这是一个端到端的校验和，如果有错，则会丢弃这个报文段
- TCP接收端会丢弃重复的数据
- **流量控制**：TCP连接的每一方都有固定大小的缓冲区，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理的时候会提示对方降低发送数据，防止包丢失。是通过滑动窗口协议实现流量控制
- **拥塞控制**：当网络拥塞时，减少数据发送
- **ARQ协议**：为了实现可靠传输，原理就是每发送完一个数据包就停止发送，等待对方确认，收到确认后再发下一组
- **超时重传**：发送出去一个数据包后会启动计时器，如果不能及时收到确认就重传

### UDP如何实现可靠传输

UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

实现确认机制、重传机制、窗口确认机制。

如果你不利用Linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：

发送：包的分片、包确认、包的重发

接收：包的调序、包的序号确认

目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

### 滑动窗口和流量控制

**TCP通过滑动窗口实现流量控制。流量控制是为了控制发送方的发送速率，保证接收方来得及接收，通过修改窗口字段设置大小。**

### 滑动窗口机制的原理和理解

GBN 协议，回退 N 步协议，这是对停等协议的改进，因为停等协议的传输效率非常低下。每次可发送的数据为 N，基数为 base，小于 base 的数据已经发送并且确认，base 是最小的已发送未确认的报文序号。在接收端同样也有一个接收窗口，（解释）GBN采用的是累计确认方式，这时候说一下选择重传机制。再说一下 TCP 中既不是 GBN 也不是 SR ，而是 GBN 和 SR 的综合体。
N 的大小必须报文序列编号的一半，否则接收端对报文的确认可能发生混淆

### ARQ协议

自动重传请求(Automatic Repeat-reQuest, ARQ)是OSI模型中数据链路层和传输层的错误纠正协议之一。如果发送方在发送一段时间之内没有收到确认帧的话，他通常会冲床。ARQ包括**停止等待ARQ协议和连续ARQ协议**

**停止等待ARQ协议**

- 基本原理是发送完一个分组就停止发送，等待对方确认，如果一段时间后没有收到确认，就重新发送
- 优点是简单，缺点是利用率低，等待时间长

**连续ARQ协议**

- 基本原理是维持一个发送窗口，在发送窗口内的分组可以连续发送，最后一个分组发送确认
- 优点：信道利用率高，容易实现，即使确认丢失，也不必重传
- 缺点：不能向发送方反应接收方收到的所有信息，出现Go-Back-N问题，表示需要退回来重传已经发送过的N个信息。

### 拥塞控制

为了进行拥塞控制，TCP发送方要位置一个拥塞窗口（cwnd）的状态变量，拥塞窗口的大小根据网络的拥塞程度并且动态变化，发送方要让自己的发送窗口取为拥塞窗口和接受窗口中较小的一个

- **慢开始**： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起 网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发 送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免**： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd 加1. 
- **快重传与快恢复**： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。**没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送**。有了 FRR，如果接收机接收到一个不按顺序的数据段，它 会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了， 并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失 时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很 有效地工作。

## HTTP（HTTPS）

### HTTP的特点

- **支持客户/服务器模式**。（C/S模式）

- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

- **灵活**：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

- **无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

- **无状态**：HTTP协议是无状态协议。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快

### HTTP的方法

**1、GET方法**

GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。

**在GET请求的URL中发送查询字符串（名称/值对**），需要这样写：

```
/test/demo_form.php?name1=value1&name2=value2
```

说明：

GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。

注：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。

**2、POST方法**

POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。

**通过body体进行参数传递**，在后退页面时，会重新提交请求

POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。

**3、HEAD方法**

HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。

**4、PUT方法**

PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。

它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。

**5、DELETE方法**

DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。

**6、CONNECT方法**

CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。

**7、OPTIONS方法**

OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。

**8、TRACE方法**

TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。

### HTTP工作流程

a.建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接

b.客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）

c.客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕

d.服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK

e.服务器向客户端发送应答头信息

f.服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端

g.服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接

### HTTPS工作流程

![image-20200821101208724](/Users/sheva/Library/Application Support/typora-user-images/image-20200821101208724.png)

### HTTP与HTTPS的区别

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### HTTP1.0与HTTP1.1的区别

- **长连接**

HTTP1.0默认使用短连接，每次请求都需要建立新的TCP连接，连接不能复用。

HTTP1.1支持持久连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少建立和关闭TCP连接的消耗和延迟，提高效率。HTTP1.1默认开启“Connection:Keep-Alive”，使用长连接，加入“Connection:close”才关闭。

- **host字段**

在HTTP1.0中为每台服务器绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但是随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚机主机，并且它们共享一个IP地址。

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域，会报400 Bad Request错误。

- **缓存处理**

在HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准。

HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

- **带宽优化及网络连接的使用**

HTTP1.0中存在一些浪费带宽的现象，例如：（1）客户端只需要某个对象的一部分，而服务器却将整个对象发送过来；(2)下载大文件不支持断点续传功能，在发生断连后需要重新下载完整的包。

HTTP1.1则在请求头中引入range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- **新增一些错误通知状态码**

HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突。

### HTTP 1.x(SPDY)

SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。为了达到减少页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。

- 多路复用，为多路复用设立了请求优先级。
- 对header部分进行了压缩。
- 引入了HTTPS加密传输。
- 客户端可以在缓存中取到之前请求的内容。

### HTTP 2.0

- HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。
- 和HTTP 1.x使用的header压缩方法不同。
- HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。
- 多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。

**HTTP2.0的多路复用提升了网页性能：**

- 在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。
- HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。

**注意：**

- 主流浏览器只支持基于TLS部署的HTTP2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。
- HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X.

### HTTP 3.0(QUIC)

QUIC (Quick UDP Internet Connections), 快速 UDP 互联网连接。
QUIC是基于UDP协议的。

两个主要特性：
**（1）线头阻塞(HOL)问题的解决更为彻底：**
基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。
**（2）切换网络时的连接保持：**
当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。

### 长连接与短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

#### TCP短连接

模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。

**短连接的优点是：**管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

#### TCP长连接

我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

#### 长连接和短连接的优点与缺点

长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。

长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。

由上可以看出，**长连接**可以**省去较多的TCP建立和关闭的操作，减少浪费，节约时间**。对于频繁请求资源的客户来说，较适用长连接。不过这里**存在一个问题**，**存活功能的探测周期太长**，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，**Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候**，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户**请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

### 状态码

- 2XX 成功状态码
- 3XX 重定向状态码
  - 301 永久重定向，表示请求的资源被分配到了新的URL
  - 302 临时重定向
- 4XX 客户端错误状态码
  - 400 请求报文中存在语法错误
  - 401 未经许可，需要通过HTTP认证
  - 403 服务器拒绝该次访问（访问权限出现问题）
  - 404 表示服务器上无法找到请求的资源
- 5XX 服务器错误状态码
  - 500 表示服务器在执行请求的时候发生了错误，也有可能是微博应用存在的bug或者某种临时的错误
  - 503表示服务器暂时处于超负载或者正在进行停机维护的状态


## 输入一个网页到显示主页的过程

- 输入网址，浏览器根据域名查找IP地址（DNS查找过程：浏览器缓存 路由器缓存 DNS缓存）
- 浏览器向web服务器发送一个HTTP请求，cookies会随着请求发送给客户端（路由器在与服务器通信的时候，需要将ip地址转换为MAC地址，需要使用ARP协议） TCP连接
- 服务器处理请求，处理各种请求参数，生成一个HTML相应
- 服务器返回一个HTML相应
- 浏览器开始显示HTML

## Cookie与Session的区别，如何使用Session进行身份验证

- Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车 的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

- Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更 高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的 时候再去服务器端解密。 那么，如何使用Session进行身份验证？ 很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例 子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候 会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：
  - 用户向服务器发送用户名和密码用于登陆系统。
  - 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。
  - 服务器向用户返回一个 SessionID，写入用户的 Cookie。
  - 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去
  - 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行 比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。

## JWT Token

### JWT的组成

- Header： 描述JWT的元数据，定义了生成签名的算法以及Token类型
- Payload：用来存放实际的数据
- Signature： 服务器通过Payload Header和一个密钥使用Header里面指定的签名算法（默认是HMAC SHA256）生成

### JWT认证的优势

- **无状态**

  token自身包含了身份验证需要的所有信息，使得我们的服务器不需要存储Session信息，增加了系统的可用性，减轻了服务端的压力。但是由于无状态，也导致了最大的缺点：如果后端在有效期内废除一个token或者修改权限的话，不会立即生效，一般需要等到有效期过后才可以，另外当用户登出的话，token也还有效。

- **避免了CSRF攻击**

  Cross Site Request Forgery  一般被翻译为跨站请求伪造，属于网络攻击的范围。

  主要就是利用你的身份去发送一些对你不友好的请求。因为Session认证中Cookies中sessionid是由浏览器发送到服务端的，借助这个特性，攻击者可以通过让用户误点攻击链接，达到攻击效果

  使用了JWT后，我们登录成功获得token之后，一般会选择存放在local storage中。然后我们在前端通过某些方式会给每个发送到后端的请求上加上这个token，这样就不会出现CSRF攻击。

- **适合移动端**

  如果用session进行身份认证，需要保存一份信息在服务端，而且这种方式会依赖到Cookie（需要Cookie保存SessionId）， 不适合移动端

  但是，使用token进行身份认证就不会出现这种问题，因为只要token可以被客户端存储就能够使用，而且token还可以跨语言

- **单点登录友好**

  如果使用session进行身份认证实现单点登录，需要我们把用户的session信息保存在一台电脑上，而且会出现cookie跨域问题。但是如果使用token的话，token被保存在客户端 不存在这些问题

### Token常见问题

**1. 注销登录场景下token还有效**

- 退出登录
- 修改密码
- 服务端修改了某个用户权限
- 用户的账户被删除
- 用户由管理员注销

**解决方案：**

- 将token存入redis，失效了直接从redis删除，但是这样就违背了无状态原则
- 黑名单机制，与上同理，每次使用token都要判断是否存在于黑名单中
- 保持令牌的有效期限并且经常轮换

对于修改密码之后token还有效的问题比较容易：**使用用户的密码的哈希值对token进行签名，因此如果密码更改，先前的令牌将无法自动验证**

**2. token续签问题**

token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免 用户经常需要重新登录？ 

我们先来看看在 Session 认证中一般的做法：假如 session 的有效期30分钟，如果 30 分钟内用户有访 问，就把 session 有效期被延长30分钟。 

- **类似于 Session 认证中的做法**：这种方案满足于大部分场景。假设服务端给的 token 有效期设置 为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做 法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。 
- **每次请求都返回新 token **:这种方案的的思路很简单，但是，很明显，开销会比较大。
- **token 有效期设置到半夜 **：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录， 适用于对安全性要求不高的系统。 
- **用户登录返回两个 token** ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半 个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生 成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是： 需要客户端 来配合； 用户注销的时候需要同时保证两个 token 都无效； 重新请求获取 token 的过程中会 有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提 前去通过 refreshToken 获取新的accessToken）。

# JVM

## Java内存区域

![image-20200813235413613](/Users/sheva/Library/Application Support/typora-user-images/image-20200813235413613.png)

- **程序计数器**

  是一块比较小的内存空间，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。（是**唯一一个不会出现OOM的内存区域**，他的生命周期由线程创建而创建，线程的消亡而消亡）

  **主要作用**：

  - 通过改变程序计数器来依次读取指令，从而实现代码的流程控制
  - 多线程情况下，用于保存当前线程执行的位置，从而当线程被切换回来的时候能够知道线程运行的位置

- **虚拟机栈**

  其生命周期与线程相同，描述的是Java方法执行的内存模型，每次方法调用都是通过栈进行传递。栈内存就只指虚拟机栈，或者说虚拟机栈中的局部变量表部分（虚拟机栈由一个个栈帧组成，而每个栈帧都拥有局部变量表，操作数栈，动态链接，方法出口等信息）

  局部变量表主要存放了各种数据类型的对象引用。

  - StackOverFlowError：内存大小不允许动态扩展，当栈的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出该错误
  - OutOfMemoryError: 内存用完了，就会抛出错误

- **本地方法栈**

  本地方法栈为虚拟机使用的Native方法服务，在HotSpot虚拟机中与Java虚拟机栈合二为一
  
- **堆（Heap）——运行时数据区**

  是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域。由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以 细分为: 新生代(Eden 区、From Survivor 区和 To Survivor 区)和老年代。

- **方法区（永久代）**

  即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型 的卸载, 因此收益一般很小)。 

  运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版 本、字段、方法、接口等描述等信息外，还有一项信息是常量池 ，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量 池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会 被虚拟机认可、装载和执行。

## 堆内存详解（对应的垃圾回收算法）

此内存区域的唯一目的就是存放对象实例，几乎**所有的对象实例以及数组**都在这里分配内存

Java堆是垃圾收集器管理内存的主要区域，因此也被称为是GC堆（Garbage Collected Heap）。从垃圾回收角度，现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以分为：**新生代和老年代**，再细致一点有：**Eden空间、From Survivor、To Survivor空间**等。进一步划分的**目的是更好的回收内存**。

JDK7之前，堆内存通常被分为以下三个部分：

- **新生代（Young Generation）**

  是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。

  - **Eden区**

    Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老 年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行 一次垃圾回收。

  - **SurvivorFrom**

    上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

  - **SurvivorTo**

    保留了一次 MinorGC 过程中的幸存者。

  **MinorGC过程**

  - **eden、servicorFrom 复制到 ServicorTo，年龄+1**

    首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不 够位置了就放到老年区）；

  - **清空 eden、servicorFrom**

    然后，清空 Eden 和 ServicorFrom 中的对象；

  - **SurvicorTo 和 SurvicorFrom 互换**

    最后，SurvicorTo 和 SurvicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 SurvicorFrom 区。

  ![image-20200814025858178](/Users/sheva/Library/Application Support/typora-user-images/image-20200814025858178.png)

- **老年代（Old Generation）**

  主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

  **MajorGC 采用标记清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

- **永久代（Permanent Generation）**

  指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这 也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

  JDK8之后方法区（HotSpot的永久代）被彻底移除了，取而代之的是元空间，元空间使用的是直接内存（永久代与元空间是对方法区的一种实现方式）

- **Java8与元空间（META SPACE）**

  在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。

  - JDK7之前，常量池逻辑包含字符串常量池存放在方法区，此时hotspot对于方法区的实现是永久代
  - JDK7字符串常量池从方法区拿到了堆中，运行时常量池还在方法区，也就是永久代中
  - JDK8之后移除了永久代，用元空间取而代之，此时字符串常量池还在堆中，运行时常量池还在方法区，只不过方法区的实现由永久代变成了元空间

  **为什么要用元空间代替永久代**

  - 字符串存在永久代中，容易出现性能问题与内存溢出
  - 类以及方法的信息比较难确定大小，对于永久代的大小指定比较困难，太小容易永久代溢出，太大容易老年代溢出
  - 永久代会为GC带来不必要的复杂度，而且回收效率低
  - 将HotSpot与JRockeit合二为一

## 堆内存分配策略

- 对象优先分配在eden 区，eden区没有足够空间，将触发一次Minor GC
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判定：如果Survivor中存在年龄相同的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等待到MaxTenuringThreshold要求的年龄
- 空间分配担保： XX:HandlePromotionFailure

## 垃圾回收相关（GC）

### 垃圾回收的优点以及原理

使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以**有效的防止内存泄露**，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。不再会被使用的对象的内存不能被回收，就是内存泄露

### 垃圾回收算法

- **标记-清除算法**

  算法分为“标记”和“清除”阶段：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。容易有效率问题与空间问题

  **缺点**：效率问题 空间问题（产生大量不连续碎片）

- **标记-整理算法**

  根据老年代的特点提出的一种算法。过程与标记清除类似。但是后续是将存活的对象向一端移动，然后直接清理掉端边界以外的内存。

- **复制算法**

  他可以将内存分为大小相同的两块，每次使用其中的一块。当这一块被用完之后，将还存活的对象复制到另一块内存区域，然后把原来的内存一次性清除

  **优点：** 实现简单，内存效率高，不容易产生碎片

  **缺点**： 可用内存被压缩到了原来的一半，且存活的对象增多的话，效率会降低

- **分代收集算法**

  当前虚拟机都是采用分代收集算法，根据对象的存活周期将内存分为几块。根据各个年代的特点选择不同的收集算法

  - 新生代 新生代对象生命周期比较短，死亡较快，可以选择复制算法，只要付出少量对象的复制成本

  - 老年代存活概率较高，所以应该选择 标记-清除 或者 标记-整理算法进行整理

    1. JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
    2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。 
    3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。
    4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 

    5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
    6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中。

### 判断对象已经死亡的方法（如何确定垃圾）

- **引用计数法**：给对象添加一个引用计数器，每当有一个地方引用他的时候，计数器+1， 引用失效-1， 为0时就无用
- **可达性分析法**：通过一系列称为“GC Roots”的对象作为起点， 从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有任何引用链的话，则证明对象不可用（**不可达的对象并非非死不可，需要经过两次标记过程**）

### 判断一个类是无用的类

- 所有实例都被回收，也就是Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的Class对应已经没有在任何地方被引用，无法在任何地方通过反射访问该方法

### 垃圾收集器

#### Serial收集器（新生代 单线程）

- 他的单线程意义不仅仅意味着他只会用一条垃圾收集线程去完成垃圾收集工作，更重要的是他在进行垃圾回收工作的时候必须暂停其他所有工作线程，直到收集结束（Stop The World）。

  **他简单高效，对于限定单个CPU的环境，没有线程交互的开销，可以获得很高的单线程收集效率。**

  新生代**复制算法** **老年代标记整理(Serial Old)**

#### ParNew收集器：  

实际上就是Serial收集器的多线程版本

新生代**复制算法** 老年代标记整理

#### **Parallel Scavenge收集器**（新生代 多线程复制算法）

他关注的是**吞吐量**(吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）)，提高CPU利用率，主要适用于在后台运算而 不需要太多交互的任务

CMS等垃圾收集器关注点更多的是用户线程的停顿时间

是一个**使用复制算法的多线程收集器**，他看上去几乎和ParNew一样，自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别。

新生代复制算法  **老年代标记整理（Parallel Old）**， 与old可以搭配使用

![image-20200816162233802](/Users/sheva/Library/Application Support/typora-user-images/image-20200816162233802.png)

#### CMS收集器（老年代  多线程标记清除）

是一种以获取**最短回收停顿时间**为目标的收集器。它非常符合在注重用户体验的应用上。CMS收集器（Concurrent Mark Sweep）是Hotspot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作

是一种标记清除算法实现，整个过程分为四步

- **初始标记**： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；

- **并发标记**： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并 不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分 析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

  简略版:进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 

- **重新标记**： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对 象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 

- **并发清除**： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。(清除GC Roots不可达对象)

![image-20200816162135978](/Users/sheva/Library/Application Support/typora-user-images/image-20200816162135978.png)

**优点：**

并发收集，低停顿

**缺点**：

对CPU资源敏感，无法处理浮动垃圾，标记清除会导致碎片

#### G1收集器  (Garbage First)

是一款面向服务器的垃圾收集器 主要针对多核处理器以及大内存的机器。及高概率满足GC停顿时间要求的同时还具有很高的吞吐量

以下四步：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**具有以下特点**:

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过 并发的方式让 java 程序继续执行。 

- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 

- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是**基于“标记整理”算法实现的收集器**；从局部上来 看是基于“复制”算法实现的。 （不产生内存碎片）

- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了 追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

### Minor GC与Full GC分别在什么时候发生

**MinorGC（发生在新生代的垃圾收集，Minor GC非常频繁 回收速度一般）**

虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间

虚拟机在mirorGC之前会判断老年代最大的可连续空间是否大于新生代的所有对象总空间

- 如果大于的话，直接执行minorGC
- 如果小于，判断是否开启HandlerPromotionFailure，没有开启直接fullGC
- 如果开启了HandlerPromotionFailure，JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接fullGC

**FullGC（Major GC）(发生在老年代，出现了Major GC经常会伴随至少一次的Minor， 通常来说Major GC比较慢)**

- 老年代空间不足
- 持久代空间不足
- YGC出现promotion failure

### 为什么Survivor区是两个

- 如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。
- 如果 Survivor 分区是 1 个的话，假设我们把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。

- 如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，所以每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过设定）对象就升级到老生代。

### GC 调优策略

策略 1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过**“-Xmn”命令调节新生代大小（默认256M）**，最大限度 降低新对象直接进入老年代的情况。 

策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收 来说简直就是噩梦）。 **-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。 **

策略 3：合理设置进入老年代对象的年龄， **-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小**，减少老 年代的内存占用，降低 full gc 发生的频率。 

策略 4：设置稳定的堆大小，堆大小设置有两个参数： **-Xms 初始化堆大小（默认512M）， -Xmx 最大堆大小（默认1G）**。 

策略 5：注意： 如果满足下面的指标，则一般不需要进行 GC 优化： MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执 行频率不算频繁，不低于10分钟1次

## 对象（类）相关（创建 内存 访问 年龄）

### 对象的创建过程

![image-20200814031259000](/Users/sheva/Library/Application Support/typora-user-images/image-20200814031259000.png)

- **类加载检查**

  虚拟机遇到new指令时，首先会去检查这个指令的参数是否能在常量池中定位，并且检查是否被加载过，如果没有那必须执行相应的类加载机制

- **分配内存**

  在类加载检查通过后，为对象分配内存。分配方式有 **指针碰撞和空闲列表两种**

- **初始化零值**

  半初始化状态，初始化为0

- **设置对象头**

  例如对象的哈希码，GC信息等存放在对象头中 （markword klasspointer）

- **执行init方法**

  进行真正的初始化操作

### 对象内存布局

- 对象头

  主要包括markword 与 klass pointer

- 实例数据

  真正存储的有效信息

- 对齐（padding），起站位作用，必须是8字节的整数倍

### 类加载机制

#### 类加载过程

JVM 类加载机制分为五个部分：**加载，验证，准备，解析，初始化**，下面我们就分别来看一下这 五个过程。

![image-20200816201832716](/Users/sheva/Library/Application Support/typora-user-images/image-20200816201832716.png)

- 加载

  加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对 象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既 可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理）， 也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

- 验证

  这一阶段的主要目的是为了**确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求**，并 且不会危害虚拟机自身的安全。

- 准备

  准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使 用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：

  ```java
  public static int v = 8080;
  ```

  实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是 程序被编译后，存放于类构造器方法之中。 但是注意如果声明为：

  但是如果是:

  ```java
  public static final int v = 8080;
  ```

  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。

- 解析

  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中 的：

  - CONSTANT_Class_info
  - CONSTANT_Field_info
  - CONSTANT_Method_info

#### 类加载器

- **启动类加载器(Bootstrap ClassLoader)**

  负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。

- **扩展类加载器(Extension ClassLoader)**

  负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库

- **应用程序类加载器(Application ClassLoader)**

  负责加载用户路径（classpath）上的类库。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。

#### 双亲委派机制

**当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成**，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中， **只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的 Class），子类加载器才会尝试自己去加载。** 

采用双亲委派的一个好处是**比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载 器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。**

![image-20200816202508632](/Users/sheva/Library/Application Support/typora-user-images/image-20200816202508632.png)

![image-20200816202527414](/Users/sheva/Library/Application Support/typora-user-images/image-20200816202527414.png)

### 对象的访问定位

- **句柄**

  包含了对象的实例数据与类型数据各自的具体信息地址，在对象被移动时只会改变句柄中的实例数据指针，reference本身不需要修改

- **直接指针**

  速度快，节省了一次指针定位的时间开销

### 对象年龄判断

大部分情况对象首先在eden区分配，在一次新生代垃圾回收之后，如果对象还存在，则会进入s0或者s1， 并且年龄加1，当年龄增加到一定程度（默认为15岁）会被分配到老年代中。年龄阈值可以通过 **-XX:MaxTenuringThreshold**

## 强软弱虚引用

- **强引用**

  在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之 一，会造成OOM。

- **软引用**

  软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，**当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收**。软引用通常用在对内存敏感的程序中。

  可以用于实现内存敏感的高速缓存，可以和一个引用队列联合使用，如果软引用被回收，Java虚拟机就会把这个软引用加入到与之相关联的引用队列中

- **弱引用**

  弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。也可以与引用队列联合使用

- **虚引用**

  虚引用主要用来跟踪对象被垃圾回收的活动  ,在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生**

# MySQL

## ACID特性

- **原子性（Atomicity）**：是指事务是一个不可分割的最小单位，要么全部成功，要么全部失败。
- **一致性（Consistency）**： 事务执行前后，数据完整性必须保持一致。
- **隔离性（Isolation）**： 多个用户并发访问数据库时，一个用户的事务不被另一个用户的事务所干扰，各并发事务之间的数据是相互隔离的。
-  **持久性（Durability）** ： 事务一旦提交，对于数据的修改是永久的，即使数据库发生故障也不应该有任何影响。（通过redo log）实现事务的持久性。重做日志

## 并发事务产生的问题

- **脏读（Dirty Read）**： 一个事务读取到了另一个事务未提交的数据，被称为脏读。
- **丢失修改（Lost to Modify）**： 两个事务同时对同一数据进行修改，最后导致修改的丢失。
- **不可重复读（Unrepeatable Read）**： 一个事务在两次读取数据的中间，另一个事务对数据进行了修改，导致前后读取到的数据不一致。
- **幻读（Phantom Read）**： 一个事务在两次读取数据的中间，另一事务插入的几行数据，导致第一个事务会发现某些不存在的记录，被称为幻读。

**不可重复读和幻读的区别**

不可重复读的重点是修改(update, delete)，幻读的重点在于新增(insert)。

## MySQL如何保证事务

- redo log重做日志用来保证事务的持久性
- undo log回滚日志保证事务的原子性
- undo log+redo log保证事务的一致性
- 锁（共享、排他）用来保证事务的隔离性

### redo log

重做日志 redo log 分为两部分：一部分是内存中的重做日志缓冲（redo log buffer），是易丢失的；二部分是重做日志文件（redo log file），是持久的。InnoDB通过Force Log at Commit机制来实现持久性，当commit时，必须先将事务的所有日志写到重做日志文件进行持久化，待commit操作完成才算完成。

### undo log

为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log），然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

回滚日志不同于重做日志，它是逻辑日志，对数据库的修改都逻辑的取消了。当事务回滚时，它实际上做的是与先前相反的工作。对于每个INSERT，InnoDB存储引擎都会完成一个DELETE；对于每个UPDATE，InnoDB存储引擎都会执行一个相反的UPDATE。

## 事务隔离级别

- **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻 读或不可重复读。 

- **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复 读仍有可能发生。 

- **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修 改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

- **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事 务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

  这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。

事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，**使得select不用加锁**。而update、insert这些“当前读”，就需要另外的模块来解决了。

## MyISAM和InnoDB的区别

- **对于行级锁的支持** ：  InnoDB支持行级锁，而MyISAM只有表级锁
- **对于事务的支持**： InnoDB支持事务，另一者则不支持
- **对于外键的支持**： InnoDB支持外键，另一者不支持
- **对于MVCC的支持**（Multiversion Concurrency Control）： InnoDB面对高并发事务，支持MVCC，MVCC比单纯的加锁更高效，可以使用乐观锁和悲观锁来实现

## 数据库的水平与垂直切分

- **垂直切分**： 就是把表按照模块划分到不同数据库中，但是如果单表数据量过大，性能依旧存在瓶。
  - **优点**：可以使列数据变小，查询时减少Block与IO次数，可以优化表结构，利于维护
  - **缺点**： 主键会出现冗余，需要进行管理，并且会增加join操作。此外，垂直分区会让事务变得更加复杂
- **水平切分**： 把一张表按照某种规则将数据划分到不同数据库中，达到了分布式的目的。
  - **优点**： 可以支持很大的数据量，应用端改造也少（水平切分最好分库）
  - **缺点**： 分片事务难以解决，跨节点join性能较差，逻辑比较复杂

## 分库分表后全局ID如何做

- UUID：不适合，因为太长而且无序不可读，查询效率低
- 自增id：两台数据库设置不同的步长，生成不重复id的策略实现高可用。但是需要独立部署数据库实例，成本比较高
- redis生成id：性能好，灵活方便，不依赖于数据库。但是引入了新的组建使得胸更加复杂
- snowflake算法
- leaf分布式id生成性系统

## MySql锁分类

- **表级锁**：

  MySql中锁粒度最大的一种，对于当前操作的整张表都加锁，实现较为简单，消耗的资源也较少，加锁较快，不会出现死锁，并发度最低，MyISAM与InnoDB都支持表级锁

- **行级锁**： 

  是锁粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，并发度高，但是加锁的开销也大，速度较慢，会出现死锁。InnoDB支持的行级锁包括如下几种：

  - **Record Lock**：对索引项进行加锁，锁定符合条件的行。其他事物不可以修改和删除加锁项
  - **Gap Lock**：对于索引项之间的间隙进行加锁，锁定记录的范围（对于第一条记录前面与最后一条记录的后面加锁）， 不包含索引本身。其他事物不能在锁范围内插入数据，这样就防止了别的事物新增幻读行
  - **Next-Key-Lock**： 锁定索引项本身和索引范围，即Record Lock与Gap Lock的结合，可以解决幻读问题。

**虽然使用行级锁具有粒度小，并发度高等优点，但是表级锁有时候也是非常有必要的：**

- 事务更新大表中的大部分数据，用表级锁的效率更高。
- 事务过于复杂，使用行级锁很可能引起死锁导致回滚。

**表级锁和行级锁还可以进一步分别共享锁（S锁）与排它锁（X锁）** --->> 悲观锁

- **共享锁（S）**： 被称为读锁，其他用户可以并发读取数据，但是不能获取数据上的排它锁，直到已经释放S锁

- **排它锁（X）**： 被称为写锁，若事务对数据加上X锁，则其他事物不能对数据加上任何锁

  **若事务对数据加上S锁，则其他事物可以读取数据，可以对数据加上S锁；若事务对数据加上X锁，则其他数据不能对数据加上人行业类型的锁，在INSERT\UPDATE\DELETE过程中用的始终是排它锁**

- **意向共享锁（IS）**： 表示事务准备给数据加上S锁，事务在给数据加S锁之前必须先取得该**表**的IS锁

- **意向排它锁（IX）**：表示事务准备给数据航加入排它锁，事务在一个数据航加排它锁之前必须先取得该**表**的IX锁 

## 多版本并发控制（Multiversion Concurrency Control）

- MVCC是被**InnoDB**所支持的
- MVCC只能在**READ COMMITTED与REPEATABBLE READ**隔离级别下进行
- MVCC可以使用**悲观锁**与**乐观锁**来实现
- InnoDB的MVCC是通过在每行记录后面保存三个隐藏的列来实现
  - 事务ID字段：用来标识最近一次对本行记录进行修改的事务标识符
  - 回滚指针：指写入回滚段的undo log record
  - DB_ROW_ID字段： 包含着一个随着新行插入而单调递增的行ID，当由InnoDB自动产生聚集索引时，聚集索引会包括这个行ID的值,否则这个行ID不会出现在任何索引中

### MVCC具有以下特点

- 每行数据存在一个版本，每次数据更新时都更新版本
- 保存时比较版本号，如果成功，则覆盖原记录，失败则rollback

### InnoDB实现MVCC的方式

- 通过排它锁的方式修改数据
- 把修改前的数据放在undo log，通过回滚指针与数据关联
- 修改成功则啥也不做，失败则恢复undo log中的数据（rollback）

在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。

对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：

- 快照读：就是select
  - select * from table ….;
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
  - select * from table where ? lock in share mode;
  - select * from table where ? for update;
  - insert;
  - update ;
  - delete;

事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。

**写**

事务的隔离级别中虽然只定义了读数据的要求，实际上这也可以说是写数据的要求。上文的“读”，实际是讲的快照读；而这里说的“写”就是当前读了。

为了解决当前读中的幻读问题，MySQL事务使用了Next-Key锁。

## 索引

### 定义

索引 （Index） 是帮助 MySQL 高效获取数据的数据结构。
索引能极大的减少存储引擎需要扫描的数据量
索引可以把随机 IO 变成顺序 IO
索引可以帮助我们在进行 分组、 排序等操作时，避免使用临时表

索引数据结构：二叉树、红黑树、hash表、B-tree

**1、普通索引**当一张表，把某个列设为主键的时候，则该列就是主键索引

**2、唯一索引**索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

**3、主键索引**是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。

**4、组合索引**指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。

**5、全文索引**主要用来查找文本中的关键字，而不是直接与索引中的值相比较。

### 哈希索引

底层数据结构就是哈希表，在单条查询的时候可以选择哈希索引，查询性能最高

### 聚集索引与非聚集索引

- **聚集索引（InnoDB索引实现）**

  表中数据的索引和数据放在一起。主键索引就属于聚集索引

  在MySql中，InnoDB引擎的表的.ibd文件就包含了该表的索引与数据，数据文件本身就是索引文件，每个非叶子节点存储索引，叶子节点存储对应的数据

  - 优点： 查询速度非常快，因为B+树是一棵多叉平衡树，叶子节点也是有序的，定位到索引的节点，就相当于定位到了数据
  - 缺点：**依赖于有序的数据**，因为如果索引不是有序的，就在每次插入时需要排序；**更新代价大**，索引列的数据如果被改变，那么对应的索引也需要被修改，而且叶子节点还存放着数据

- **非聚集索引（二级索引）**

  表中数据和索引分开存储的索引。

  - 优点：更新代价小，因为叶子节点不存放数据
  - 缺点：**依赖于有序的数据；同时查询需要回表**

- **覆盖索引**

  如果InnoDB下存储的是普通索引，则叶子节点存储的是主键+列值，最终需要回表操作

  如果需要查询的字段覆盖了全部的索引，则无需回表就可以直接查询

## 主从模式

**主从复制可以解决什么问题**

- **高可用**
- **负载均衡**
- **数据备份**

**主从复制原理：**

主从同步过程中主服务器有一个工作线程I/O dump thread，从服务器有两个工作线程I/O thread和SQL thread。

主库把外界接收的SQL请求记录到自己的binlog日志中，从库的I/O thread去请求主库的binlog日志，并将binlog日志写到中继日志中，然后从库重做中继日志的SQL语句。主库通过I/O dump thread给从库I/O thread传送binlog日志。

**通信方面**：

- 从库的IO线程给主库发送同步请求，请求中包含用户名密码和binlog的文件名，pos点
  主库验证成功后，发送从库需要的binlog日志文件，和binlog文件中pos点
- 从库的IO线程接收后，把binlog文件转存到中继日志的relay-log文件，并把binlog文件名和pos点记录到master.info文件中，方便下次通信使用

- 从库的SQl线程监测出relay-log文件后，把relay-log文件转换为binlog文件在本地执行，并把relay-log文件名和pos点记录到relay-log.info文件中
- 从库再次发送下一轮的请求~~~

- 如果slave后面还挂有从库则也要开启binlog，并添加一个参数log-slave-updates

原理图

![image-20200815153643717](/Users/sheva/Library/Application Support/typora-user-images/image-20200815153643717.png)

**复制方式**

- 异步复制

  异步复制是MySql默认的复制方式，主库写入binlog日志后，即可成功返回客户端，无需等待binlog日志传递给从库的过程。但是一旦主机挂了，就可能出现数据丢失的情况

- 半同步复制（semi-sync）

  指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。

- 并行复制

  指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行

**主从延迟的原因**

- 慢SQL语句过多
- 从库的硬件比主库查
- 同一个主库下有过多的从库
- 网络延迟
- 表分区过多

## SQL注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
**1）SQL注入攻击的总体思路**

 ●寻找到SQL注入的位置
​ ●判断服务器类型和后台数据库类型
​ ●针对不同的服务器和数据库特点进行SQL注入攻击

**2）应对方法**
​ ●使用正则表达式过滤传入的参数
​ ●参数绑定
​ ●使用预编译手段，绑定参数是最好的防SQL注入的方法。

## redo log和binlog的区别

- 涉及存储引擎不一样：binlog记录的是所有存储引擎的操作记录redo log只记录innodb存储引擎的日志
- 记录内容不一样：binlog记录的是关于一个事务的具体操作内容。为逻辑日志而redo log记录的是每个页更改的物理情况
- 写的时间不一样：binlog文件仅在事务提交前进行提交，即只写磁盘一次而在事务进行过程中，却不断有重做日志条目被写入到重做日志文件中。

## Mysql基础架构

**Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。

**存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

- **连接器**：身份认证和权限相关

  连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。

  主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。

- **查询缓存**：执行查询语句的时候，会先查询缓存

  查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。

  连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

- **分析器**：没有命中缓存的话，SQL语句就会经过分析器，分析器说白了就是看你的sql要干嘛，再检查语法是否正确

  MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

  **第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

  **第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。

  完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

- **优化器**：按照mysql认为最优的方案去执行

  优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

  可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。

- **执行器**：执行语句，然后从存储引擎返回数据

  当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

## 一条sql语句是如何执行的

### 查询

**权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎**

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

- 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
- 接下来就是优化器进行确定执行方案
- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

### 修改

**分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit**

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

- 先查询到张三这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成

# Redis

## 五种数据结构

- **String**： key-value缓存应用，value不仅仅可以是string，还可以是数字，一般做一些复杂的计数功能。

  - 常用命令：get set decr incr mget

  - 场景：session，kv缓存，数值计数器，fs文件系统；二进制位操作

- **List**：底层是LinkedList双向链表，这意味着list的插入和删除很快，但是索引定位很慢

  - 常用命令：lpop rpop lpush rpush lrange
  - 场景：通过lrange命令，可以从某个元素读取多少个元素，可以实现分页功能，基于redis实现简单高性能的分页，性能高

- **Hash**：底层就是哈希表，通过数组+链表的链地址法来解决哈希冲突

  - 常用命令：hget hset hgetall
  - 场景：存储用户信息商品信息

- **Set**： 相当于HashSet，可以排除重复数据（无序数据）

  - 常用命令：sadd spop smenbers sunion
  - 场景：实现交并差集操作，可以实现共同好友等等

- **Sorted Set**: 有序集合，与set相比，增加了一个权重参数score，使得集合中的元素能够**按照score**进行有序排序（底层使用**跳表**数据结构）

  - 常用命令：zadd zrange zrem zcard
  - 场景：用户列表，礼物排行榜，弹幕

### 压缩列表

#### **组成**

**表头**：

表头包括四个部分，分别是内存字节数zlbytes，尾节点距离起始地址的字节数zltail_offset，节点数量zllength，标志结束的记号zlend。

![img](https://user-gold-cdn.xitu.io/2020/6/30/173045e086679c6a?w=230&h=45&f=jpeg&s=3785)![img](https://user-gold-cdn.xitu.io/2020/6/30/173045e2c18692c4?w=66&h=45&f=jpeg&s=1382)



- zlbytes：记录整个压缩列表占用的内存字节数。
- zltail_offset：记录压缩列表尾节点距离压缩列表的起始地址的字节数`（目的是为了直接定位到尾节点，方便反向查询）`。
- zllength：记录了压缩列表的节点数量。即在上图中节点数量为2。
- zlend：保存一个常数255(0xFF)，标记压缩列表的末端。

**数据节点**

数据节点包括三个部分，分别是前一个节点的长度prev_entry_len，当前数据类型和编码格式encoding，具体数据指针value。

![img](https://user-gold-cdn.xitu.io/2020/6/30/173049b68b0ad426?w=271&h=45&f=jpeg&s=4034)

- prev_entry_len：记录前驱节点的长度。
- encoding：记录当前数据类型和编码格式。
- value：存放具体的数据。

#### **优点**

在一定可控的时间复杂读条件下尽可能的减少不必要的内存开销，从而达到节省内存的效果

我认为使用压缩列表的好处除了节约内存之外，还有减少内存碎片的作用，我把这种行为叫做"合并存储"，也就是将很多小的数据块存储在一个比较大的内存区域，试想想，如果我们将要存储的数据都是很小的条目，我们为每一个数据条目都单独的申请内存，结果是这些条目将有可能分散在内存的每一个角落，最终导致碎片增加，这是一件令人头疼的事情。

#### 缺点

因为压缩表是紧凑存储的，没有多余的空间。这就意味着插入一个新的元素就需要调用函数扩展内存。过程中可能需要重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址。

如果数据量太多，重新分配内存和拷贝数据会有很大的消耗。所以压缩表不适合存储大型字符串，并且数据元素不能太多。

## 使用redis产生的问题

### 缓存雪崩

指缓存在同一时间大量失效，所有请求都落到后台数据库上导致数据库崩掉

解决方法：

- 如果是大面积失效，**则可以在失效时间内加一个随机值**，避免缓存在同一时间内失效，如果是挂掉，可以有以下思路：

- 事前：**保证redis 的高可用性（主从架构）**，尽量避免redis挂掉的情况发生，选择合适的内存淘汰策略
- 事中：**设置本地缓存（ehcache）+限流（hystrix）**，避免mysql数据库挂掉
- 事后：**redis持久化**，快速恢复数据

### 缓存穿透

恶意请求缓存中不存在的数据，所有请求都落到后台数据库而造成数据库崩掉

解决方法：

- **最基本的就是做好参数校验**，一些不合法的参数直接抛出异常给客户端
- **将无效的key进行缓存**，可以解决key不频繁变换的情况
- **布隆过滤器**：把所有可能存在的请求都存放在布隆过滤器中，当用户请求过来，先判断key是否在布隆过滤器中，若不存在则直接返回异常给客户端

### redis双写一致性

**读**

- 先读缓存，如果数据命中就返回
- 如果数据未命中，则读数据库
- 将db中读取出来的数据写入缓存

**写**

- 先淘汰缓存
- 再写数据库

**数据不一致的原因** 

先操作缓存，在写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。
在分布式环境下，数据的读写都是并发的，上游有多个应用，通过一个服务的多个部署（为了保证可用性，一定是部署多份的），对同一个数据进行读写，在数据库层面并发的读写并不能保证完成顺序，也就是说后发出的读请求很可能先完成（读出脏数据）。

![image-20200909224005303](/Users/sheva/Library/Application Support/typora-user-images/image-20200909224005303.png)

**上图解析：** 写操作先执行1，删除缓存，再执行2，更新db；而读操作先执行3，读取cache数据，未找到数据时执行4，查询db。
**问题所在：** 写操作2没执行完时，读操作4执行了，则读到了脏数据到cache中，造成了cache和db的数据不一致问题。

**解决方案**

1. 将**读写请求串行化**，串到一个内存队列里，但是会大幅降低系统吞吐量
2. **先更新数据库，再删除缓存**。但是可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列
3. 采用**延时双删策略**。
   （1）先淘汰缓存
   （2）再写数据库（这两步和原来一样）
   （3）休眠1秒，再次淘汰缓存
   这么做，可以将1秒内所造成的缓存脏数据，再次删除。(为何是1秒？需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。当然这种策略还要考虑redis和数据库主从同步的耗时。)

### 如何解决redis并发竞争key的问题

并发竞争key就是多个系统同时对一个key进行操作，但是最后执行的顺序和我们期望的顺序不同，也就导致了结果的不同

推荐使用zookeeper分布式锁，大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将该瞬时节点删除即可

## 布隆过滤器（Bloom Filter）

- 基于布隆算法：通过一定的错误率（由于存在哈希碰撞）来换取空间。通过一个bit数组和**一系列**（通过增加哈希函数的个数来降低错误率）哈希函数构成。
- 如果通过布隆过滤器，显示数据存在，那么数据可能不存在；如果显示数据不存在，那么一定不存在。

## redis内存淘汰机制（如何保证redis中都是热点数据）

- volatile-lru：从已设置过期时间的数据集中选择最近最少使用数据淘汰
- volatile-ttl： 从已设置过期时间的数据集中选择将要过期的数据进行淘汰
- volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
- allkeys-lru：在键空间中，移除最近最少使用的key进行淘汰（最常用）
- allkeys-random：从数据集中任意选择数据淘汰
- no-eviction： 禁止驱逐数据
- volatile-lfu：从已设置过期时间的数据集中选择最不经常使用的数据淘汰
- allkeys-lfu：在键空间中，移除最不经常使用的key

## 持久化机制（如何保证redis挂掉之后重启数据可以进行恢复）

**1. 快照（snapshotting）持久化（RDB）**

通过快照来存储内存中的数据在某个时间点上的副本，创建快照后可以对快照进行备份，这是redis默认的持久化方式，在redis.conf中可以配置

**优点**：

- 适合用于灾难恢复（Disaster Recovery）
- 可以最大化redis性能，父进程在保存RDB文件时只要fork出一个子线程，然后这个子进程就会处理接下来所有操作，父进程无需进行任何IO操作
- 恢复大数据时比AOF的方式快

**缺点**：

在备份时间间隙中的数据可能丢失，实时性较差

**2. AOF（append-only file）持久化**

与快照持久化相比，AOF持久化的实时性更好，因此已经成为主流的持久方案，可以通过参数 appendonly yes进行开启

开启AOF持久化之后，每执行一条redis更新操作，redis就会命令写入AOF文件。AOF文件的保存位置与RDB的保存为止相同，都是通过dir参数进行设置的

**优点：**

1. 具有更好的实时性，使得redis变得非常耐久
2. 有序的保存了redis的所有更新操作，可读性更强

**缺点**：

1. 文件体积过大

**3. 混合持久化**

在redis4.0之后支持混合持久化，可以通过配置项**aof-use-rdb-preamble**进行配置，集合了AOF与RDB的优点

## redis事务

redis通过**MULTI,EXEC,WATCH**等命令实现事务操作

在事务运行期间，虽然redis命令可能会执行失败（语法错误），但是redis仍然会执行接下来的命令，不会执行回滚操作

## 为什么redis读写速率快，性能好

- redis是**纯内存数据库**， 物理性能上的优势
- **多路复用IO**： 多个网络连接复用同一个线程，可以让单个线程同时处理多个请求，避免了线程切换导致的时间和性能消耗

## 一致性Hash算法

hash一致性算法**主要解决的是当集群中有机器发生变动，不至于发生大量的数据移动问题（解决小范围数据移动）**

服务器位置：hash(ip+编号)%2^32

hash环主要有2^32个点，位置的计算就是hash(key)% 2^32

![image-20200821184012183](/Users/sheva/Library/Application Support/typora-user-images/image-20200821184012183.png)

#### 简单一致性hash算法

**原理**

- 是构造一个hash环，这个环是一个范围，比如[0,1)

- 对服务器负载散列到环上（使用hash算法）
- 对客户端请求散列到环上，按照顺逆时间找到最近的服务器负载

**缺点**

- 如果集群有一台机器挂掉，有可能导致挂掉的机器的请求全部打到隔壁机器，那么隔壁机器可能雪崩

- 如果新增一台机器，那么机器5只分担了某台机器的负载请求，这个集群其他机器负载没有受到变化

- 机器机器分配不均，会发生数据倾斜问题

  ![image-20200821184420851](/Users/sheva/Library/Application Support/typora-user-images/image-20200821184420851.png)

#### 一致性hash算法

**原理**

- 构造一个一致性hash环，这个环是一个范围，比如[0,1)
- 对服务器负载和**虚拟服务器负载（虚拟节点）**散列到环上
- 对客户端请求散列到环上，按照顺逆时针找到最近的服务器负载

**解析**

- 并不是均匀散列，只是保持相对均衡
- 只能缓解系统雪崩，无法彻底解决雪崩
- 一致性hash算法是比简单一致性hash算法多了虚拟服务器负载计算hash的过程
- 一致性hash算法虚拟服务器节点不能太多，否则节点数据结构过大会影响性能

# Spring

## 优点

- **非入侵式设计**

  允许在应用系统中自由选择和组装Spring框架的各个功能模块，并且不强制要求应用系统的类必须从Spring框架的系统API的某个类来继承或者实现某个接口。从编写者的角度来看，察觉不到框架的存在，允许锁开发出来的应用系统能够在不同的环境中自由移植，不需要修改因故用系统中的核心功能实现的代码。

- **降低耦合度**

  通过IOC容器，我们可以将对象之间的依赖关系由Spring进行控制，避免硬编码造成的程序过度耦合，更加注重上层的应用逻辑

- **AOP**

  在不修改代码的情况下可以达到进行增强，减少了重复代码，提高了开发效率

- **支持声明式事务处理**

  可以通过声明式方式灵活的进行实物的管理，提高开发效率和质量

- **方便程序的测试**

  用非容器依赖的编程方式进行几乎所有的测试工作

- **方便集成各种优秀的框架**

- **降低Java EE API的使用难度**

  Spring对很多难用的Java EE API（如JDBC,，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简单封装，这些API的使用难度大为降低

## IOC

### IOC是什么，DI是如何实现的


IoC叫控制反转，DI叫依赖注入。控制反转是把传统上由程序代码直接操控的对象的调用权交给**容器**，**通过容器来实现对象组件的装配和管理**。"控制反转"就是**对组件对象控制权的转移**，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，即**由容器动态的将某种依赖关系注入到组件之中。**

依赖注入可以通过**setter方法注入（设值注入）、构造器注入和接口注入**三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。

依赖注入是从应用程序的角度在描述：**应用程序依赖容器**创建并注入它所需要的外部资源；

控制反转是从容器的角度在描述：**容器控制应用程序**，由容器反向的向应用程序注入应用程序所需要的外部资源。

### IOC的原理是什么？如果要手动实现要怎么做？优点是什么

IoC这是spring的核心，由spring来负责**控制对象的生命周期和对象间的关系**。

IoC的一个在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI来实现的。比如对象A需要操作数据库，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像***一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。主要是通过反射实现依赖注入。

**优点：**

- 降低类之间的耦合度
- 倡导现象接口编程，实施依赖倒置原则
- 提高系统可插入，可测试，可修改等特性


## AOP

### AOP原理

AOP指面向切面编程，用于**处理系统中分布于各个模块的横切关注点**，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常**使用AspectJ的编译时增强实现AOP**，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。

Spring AOP中的动态代理主要有两种方式，**JDK动态代理**和**CGLIB动态代理**。

- **JDK动态代理**通过反射来接收被代理的类，并且**要求被代理的类必须实现一个接口**。核心是InvocationHandler接口和Proxy类。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。
- **CGLIB**（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。通过修改字节码文件的方式。

### AOP中的相关概念

- **连接点（Joinpoint）：**

  程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。

- **切点（PointCut）：**

  如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。

- **增强（Advice）：**

  增强是织入到目标类连接点上的一段程序代码。

- **引介（Introduction）：**

  引介是一种特殊的增强，它为类添加一些属性和方法。

- **织入（Weaving）：**

  把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:
  
  (1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器
  
  (2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码
  
  (3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术

### AOP实现方式

第一种：静态织入，即在编译时，就将各种涉及AOP拦截的代码注入到符合一定规则的类中，编译后的代码与我们直接在RealA调用属性或方法前后增加代码是相同的，只是这个工作交由编译器来完成。

第二种：EMIT反射，即：通过Emit反射动态生成代理类

第三种：普通反射+利用Remoting的远程访问对象时的直实代理类来实现

### AOP应用场景

Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。

## MVC

Spring MVC框架是有一个MVC框架，通过实现Model-View-Controller模式来很好地将数据、业务与展现进行分离。

### MVC的六大组件

- **DisPatcherServlet 前端控制器** 
  核心。用户在浏览器输入url，发起请求，首先会到达DisPatcherServlet，由它来调用其他组件来配合工作的完成，DisPatcherServlet的存在大大降低了组件之间的耦合性 
- **HandlerMapping 处理器映射器**
  记录url与处理器的映射，方式有注解、XML配置等 
- **HandLer 处理器 **
  后端控制器（通俗一点：Controller层所写的业务代码）。对用户的请求进行处理 
- **HandlerAdapter 处理器适配器** 
  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。（我也不太明白） 
- **ViewResolver 视图解析器** 
  ViewResolver负责解析view视图，并进行渲染（数据填充），将处理结果通过页面展示给用户看 
- **View 视图 **
  View是一个接口，实现类支持不同的View类型（jsp、freemarker、velocity） 
  一般情况下需要通过页面标签或者页面模板技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 

### MVC的流程

  1）用户发送请求至前端控制器DispatcherServlet
（2）Dispatcher Servlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler
（3）处理器映射器根据请求url获取具体的处理器，返回给DispatcherServlet
（4）DispatcherServlet调用HandlerAdapter处理器适配器
（5）处理器适配器经过适配调用具体的处理器
（6）Hander执行完成返回ModelAndView
（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet
（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析
（9）ViewResolver经过解析后返回具体View
（10）DispatcherServlet对View进行渲染视图
（11）DispatcherServlet响应用户

## 核心组件

### Bean组件

Bean组件在Spring的 org.springframework.beans 包下，在这个包下的所有类主要解决了3件事：Bean的定义、Bean的创建及对Bean的解析。对Spring使用者来说唯一需要关心的就是Bean的创建，其他两个由Spring在内部完成。BeanDefination：Bean的定义完整的描述了在 Spring配置文件中定义的<bean/>节点中所有的信息，包括各种子节点。当 Spring成功解析 <bean/> 节点后，在Spring内部它就被转化成 BeanDefinition对象，以后所有操作都是对这个对象操作。

Bean的解析过程非常复杂，功能被分的很细。因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。

### Context组件

```shell
Context 在 Spring的 org.springframework.context 包下，给 Spring提供一个运行时的环境，用于保存各个对象的状态。ApplicationContext 是 Context 的父类，它除了能标识一个应用环境的基本信息外，还集成了5个接口来扩展 Context 的功能。例如：通过继承 BeanFactory 表明容器中运行的主体对象是 Bean，另外继承了 ResourceLoader接口，使得 ApplicationContext可以访问外部资源（在Core中说明）；
```

【1】ApplicationContext 的子类主要包含两个方面：
  ● ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中，用户可以动态添加或修改已有的配置信息，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContex类；
  ● WebApplicationContext 为Web装备的Context，可直接访问ServletContext；

【2】再往下分别就是构建 Context的文件类型，接着就是访问 Context的方式，这样一级一级构成了完成的 Context等级层次。总体来说 ApplicationContext 必须要完成一下几件事情：
  ✔ 标识一个应用环境；
  ✔ 利用 BeanFactory创建Bean对象；
  ✔ 保存对象关系表；
  ✔ 能够捕捉各种事件；
Context 作为 Spring的IOC容器，基本上整合了 Spring的大部分功能，或者说是大部分功能的基础。

### Core组件

Core 组件作为 Spring的核心组件，其中包含了很多关键类，例如：定义了资源的访问方式。这种将所有资源都抽象成一个接口的方式很值得以后的设计中拿来学习。

Context 与 Core之间的关系：比如 Context一般会把资源的加载、解析和描述工作委托给 ResourcePatternResolver类来完成，它相当于一个接头人，把资源的加载、解析和资源的定义整合在一起便于其他组件使用，在Core组件中还有很多类似的方式。

## Spring Bean的作用域（Scope）

- **singleton**

  使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。

- **prototype**

  使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。

- **request**

  该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。

- **session**

  该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。

- **global-session**

  该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。

## 常用注解

springboot常用注解

- @SpringBootApplication

  包含@Configuration、@EnableAutoConfiguration、@ComponentScan
  
  通常用在主类上。
  
- @Repository

  用于标注数据访问组件，即DAO组件。

- @Service

  用于标注业务层组件。

- @RestController

  用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody

- @ResponseBody

  表示该方法的返回结果直接写入HTTP response body中

  一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。

- @Component

  泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

- @ComponentScan

  组件扫描。相当于，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。

- @Configuration

  指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。

- @Bean

  相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。

- @EnableAutoConfiguration

  让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。

- @AutoWired

  byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。
  当加上（required=false）时，就算找不到bean也不报错。

- @Qualifier

  当有多个同一类型的Bean时，可以用@Qualifier("name")来指定。与@Autowired配合使用

- @Resource(name="name",type="type")

  没有括号内内容的话，默认byName。与@Autowired干类似的事。

- @RequestMapping

  RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

  该注解有六个属性：

  - params:指定request中必须包含某些参数值是，才让该方法处理。

  - headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。

  - value:指定请求的实际地址，指定的地址可以是URI Template 模式

  - method:指定请求的method类型， GET、POST、PUT、DELETE等

  - consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;

  - produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回

- @RequestParam

  用在方法的参数前面。

- @Profiles

  Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。

  任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。

- @ControllerAdvice全局异常处理

  包含@Component。可以被扫描到。

- 统一处理异常  @ExceptionHandler（Exception.class）：

## Spring中自动装配的方式有哪些

- byName： 根据Bean名字自动装配
- byType： 根据Bean类型自动装配
- constructor： 类似byType 不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同，则可以自动装配，否则会产生错误
- Autodetect： 如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式

## Spring如何解决循环依赖（只能解决单例作用域的循环依赖）

**Spring中循环依赖的情况**

- **构造器注入形成的循环依赖。**也就是beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成舒适化，这种情况的结果就是两个bean	都不能完成初始化，循环依赖难以解决。
- **setter注入构成的循环依赖。**beanA需要在beanB的setter方法中完成初始化，beanB也需要在beanA的setter方法中完成初始化，spring设计的机制主要就是解决这种循环依赖
  - 将beanA进行初始化，然后将自己初始化的状态记录下来，并向外暴露一个单例工厂（ObjectFactory），从而使其他bean能够引用到这个bean
  - beanA中有beanB的依赖，开始初始化B
  - 初始化beanB的过程中又发现beanB依赖了beanA,于是又进行beanA的初始化，这时发现beanA已经在进行初始化了，程序发现了存在的循环依赖，**然后通过步骤一中暴露的单例工厂方法拿到beanA的引用（注意，此时的beanA只是完成了构造函数的注入但为完成其他步骤）**，从而beanB拿到beanA的引用，完成注入，完成了初始化，如此beanB的引用也就可以被beanA拿到，从而beanA也就完成了初始化。
- **prototype作用域bean的循环依赖。**这种循环依赖同样无法解决，因为spring不会缓存prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。

## Spring生命周期

![image-20200814232810040](/Users/sheva/Library/Application Support/typora-user-images/image-20200814232810040.png)

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
6. 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。

``` java
//做一个启动类的测试
public class SpringBeanLifecycleApplication {

    public static void main(String[] args) throws InterruptedException {
        // 为面试而准备的Bean生命周期加载过程
        ApplicationContext context = new ClassPathXmlApplicationContext("Bean-Lifecycle.xml");
        Book book = (Book)context.getBean("book");
        System.out.println("Book name = " + book.getBookName());
        ((ClassPathXmlApplicationContext) context).destroy();
    }
}
```

输出结果如下

```java
Book Initializing 
setBookName: Book name has set.
Book.setBeanName invoke
Book.setBeanFactory invoke
Book.setApplicationContext invoke
MyBeanPostProcessor.postProcessBeforeInitialization
@PostConstruct
Book.afterPropertiesSet invoke
Book.myPostConstruct invoke
MyBeanPostProcessor.postProcessAfterInitialization
Book name = thingking in java

@PreDestory
Book.destory invoke
Book.myPreDestory invoke
---------------destroy-----------------
  
```

## Spring中的设计模式

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

  **工厂模式**

  工厂模式提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**。

  **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

  主要解决：主要解决接口选择的问题。

  何时使用：我们明确地计划不同条件下创建不同实例时。

  如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

  是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能，解决方案是在控制
  器里面不能写字段。

- **代理设计模式** : Spring AOP 功能的实现。

  在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。

- **单例设计模式** : Spring 中的 Bean 默认都是单例的。

  保证一个类仅有一个实例，并提供一个访问它的全局访问点。
  spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。 Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定

- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

  Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

- **策略模式**

  Spring的事务管理机制就是典型的策略模式，Spring事务策略是通过PlatformTransactionManager接口实现的，它是整个Spring事务的核心。它是对事务策略的一个高度抽象，不依赖于任何具体的事务策略，而对于底层的具体的事务策略它相应的有不同的实现类。而对于不同的事务策略的切换通常由Spring容器来负责管理，应用程序既无须与具体的事务API耦合，也无须与特定的实现类耦合而将应用和持久化技术，事务API彻底分离开来。

# SpringBoot

Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手

## 优点

- **独立运行**

  Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。

- **简化配置**

  spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。

- **自动配置**

  Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。

- **无代码生成和XML配置**

  Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。

- **应用监控**

  Spring Boot提供一系列端点可以监控服务及应用，做健康检测。

## SpringBoot常用注解

### SpringBootApplication

Spring Boot的项目一般都会有XxxApplication的入口类，入口类中会有main方法，这是一个标准的Java应用程序的入口方法。
这个入口类都会有@SpringBootApplication注解，它让Spring Boot自动给程序进行必要的配置，该注解是SpringBoot特有的。
这个配置等同于以下几个注解之和：

- **@SpringBootConfiguration，继承自@Configuration注解，主要用于加载配置文件**

  @SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。

- **@EnableAutoConfiguration， 开启自动配置功能**

  @EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成

- **@ComponentScan，主要用于组件扫描和自动装配**

  @ComponentScan的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过basePackages等属性指定@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现从声明@ComponentScan所在类的package进行扫描，默认情况下是不指定的，所以SpringBoot的启动类最好放在root package下。

### Controller相关

- **@Controller**

  控制器，处理http请求

- **@RestController**

  相当于@ResponseBody+@Controller合在一起的作用，RestController主要是讲返回的对象直接在浏览器上显示json格式

- **@RequestBody**

  通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对

- **@RequestMapping**

  @RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上

- **@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解**

  注解简写：@RequestMapping(value = "/say",method = RequestMethod.GET)等价于：@GetMapping(value = "/say")

### 请求参数相关

- **@PathVariable： 获取url中的数据**

  ```java
  @Controller
  @RequestMapping("/User")
  public class HelloWorldController {
  
      @RequestMapping("/getUser/{uid}")
      public String getUser(@PathVariable("uid")Integer id, Model model) {
          System.out.println("id:"+id);
          return "user";
      }
  }
  ```

  请求示例：http://localhost:8080/User/getUser/123

- **@RequestParam：获取请求参数的值**

  ```java
  @Controller
  @RequestMapping("/User")
  public class HelloWorldCOntroller{
    @RequestMapping("/getUser")
    public String getUser(@RequestParam("uid") Integer id, Model model){
      return "user";
    }
  }
  ```

  请求示例：http://localhost:8080/User/getUser?uid=123

- **@RequestHeader 把Request请求header部分的值绑定到方法的参数上**

- **CookieValue 把Request header中关于cookie的值绑定到方法的参数上**

### 注入bean相关

- **@Repository**

- **@Service**

  - @Service是@Component注解的一个特例，作用在类上
  - @Service注解作用域默认为单例
  - 使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean
  - @Service用于标注服务层组件,表示定义一个bean
  - @Service使用时没有传参数，Bean名称默认为当前类的类名，首字母小写
  - @Service(“serviceBeanId”)或@Service(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字

- **@Scope**

  @Scope作用在类上和方法上，用来配置 spring bean 的作用域，它标识 bean 的作用域

- **@Entity实体类注解**

  @Table(name ="数据库表名")，这个注解也注释在实体类上，对应数据库中相应的表。
  @Id、@Column注解用于标注实体类中的字段，pk字段标注为@Id，其余@Column。

- **@Bean产生一个bean的方法**

  @Bean明确地指示了一种方法，产生一个bean的方法，并且交给Spring容器管理。支持别名@Bean("xx-name")

- **@Autowired自动导入**

  - @Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上
  - @Autowired注解可以实现Bean的自动注入

- **@Component**

  把普通pojo实例化到spring容器中，相当于配置文件中的

  虽然有了@Autowired,但是我们还是要写一堆bean的配置文件,相当麻烦,而@Component就是告诉spring,我是pojo类,把我注册到容器中吧,spring会自动提取相关信息。那么我们就不用写麻烦的xml配置文件了

### 导入配置文件

- **@PropertySource注解**

  引入单个properties文件：

  @PropertySource(value = {"classpath : xxxx/xxx.properties"})

  引入多个properties文件：

  @PropertySource(value = {"classpath : xxxx/xxx.properties"，"classpath : xxxx.properties"})

- **@ImportResource导入xml配置文件**

  可以额外分为两种模式 相对路径classpath，绝对路径（真实路径）file

  注意：单文件可以不写value或locations，value和locations都可用

  相对路径（classpath）

  - 引入单个xml配置文件：@ImportSource("classpath : xxx/xxxx.xml")
  - 引入多个xml配置文件：@ImportSource(locations={"classpath : xxxx.xml" , "classpath : yyyy.xml"})

  绝对路径（file）

  - 引入单个xml配置文件：@ImportSource(locations= {"file : d:/hellxz/dubbo.xml"})
  - 引入多个xml配置文件：@ImportSource(locations= {"file : d:/hellxz/application.xml" , "file : d:/hellxz/dubbo.xml"})

  取值：使用@Value注解取配置文件中的值

  @Value("${properties中的键}")
  private String xxx;

- **@Import导入额外的配置信息**

  功能类似XML配置的，用来导入配置类，可以导入带有@Configuration注解的配置类或实现了ImportSelector/ImportBeanDefinitionRegistrar。

  ```java
  @SpringBootApplication
  @Import({SmsConfig.class})
  public class DemoApplication {
      public static void main(String[] args) {
          SpringApplication.run(DemoApplication.class, args);
      }
  }
  ```

### 事务注解@Transactional

在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式

- 编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。
- 声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用

### 全局异常处理

- **@ControllerAdvice统一处理异常**

- **@ExceptionHandler注解声明异常处理方法**

  ```java
  @ControllerAdvice
  public class GlobalExceptionHandler {
  
      @ExceptionHandler(Exception.class)
      @ResponseBody
      String handleException(){
          return "Exception Deal!";
      }
  }
  ```

## SpringBoot的配置文件

- **application**

  主要用于SpringBoot项目的自动化配置

- **bootstrap**

  - 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息
  - 一些固定的不能被覆盖的属性
  - 一些加密/解密的场景

Spring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。

## SpringBoot启动流程

SpringBoot整个启动流程分为两个步骤：**初始化一个SpringApplication对象、执行该对象的run方法。**

### SpringApplication初始化

看下SpringApplication的初始化流程，SpringApplication的构造方法中调用initialize(Object[] sources)方法，其代码如下:

```java
private void initialize(Object[] sources) {
      if (sources != null && sources.length > 0) {
          this.sources.addAll(Arrays.asList(sources));
      }
      // 判断是否是Web项目
      this.webEnvironment = deduceWebEnvironment();
      setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
      setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
      // 找到入口类
      this.mainApplicationClass = deduceMainApplicationClass();
 }
```

初始化流程中最重要的就是通过SpringFactoriesLoader找到spring.factories文件中配置的ApplicationContextInitializer和ApplicationListener两个接口的实现类名称，以便后期构造相应的实例。

ApplicationContextInitializer的主要目的是在ConfigurableApplicationContext做refresh之前，对ConfigurableApplicationContext实例做进一步的设置或处理。

ConfigurableApplicationContext继承自ApplicationContext，其主要提供了对ApplicationContext进行设置的能力。

实现一个ApplicationContextInitializer非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个ApplicationContextInitializer，即便是Spring Boot框架，它默认也只是注册了两个实现，毕竟Spring的容器已经非常成熟和稳定，你没有必要来改变它。

而ApplicationListener的目的就没什么好说的了，它是Spring框架对Java事件监听机制的一种框架实现，具体内容在前文Spring事件监听机制这个小节有详细讲解。这里主要说说，如果你想为Spring Boot应用添加监听器，该如何实现？

**Spring Boot提供两种方式来添加自定义监听器：**

- 通过SpringApplication.addListeners(ApplicationListener... listeners)或者SpringApplication.setListeners(Collection> listeners)两个方法来添加一个或者多个自定义监听器

- 既然SpringApplication的初始化流程中已经从spring.factories中获取到ApplicationListener的实现类，那么我们直接在自己的jar包的META-INF/spring.factories文件中新增配置即可：

  ```java
  org.springframework.context.ApplicationListener=\ cn.moondev.listeners.xxxxListener\
  ```

### SpringApplication.run方法

Spring Boot应用的整个启动流程都封装在SpringApplication.run方法中，其整个流程真的是太长太长了，但本质上就是在Spring容器启动的基础上做了大量的扩展，按照这个思路来看看

```java
public ConfigurableApplicationContext run(String... args) {
         StopWatch stopWatch = new StopWatch();
         stopWatch.start();
         ConfigurableApplicationContext context = null;
         FailureAnalyzers analyzers = null;
         configureHeadlessProperty();
         // ①
         SpringApplicationRunListeners listeners = getRunListeners(args);
         listeners.starting();
         try {
             // ②
ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
             ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
             // ③
             Banner printedBanner = printBanner(environment);
             // ④
             context = createApplicationContext();
             // ⑤
             analyzers = new FailureAnalyzers(context);
             // ⑥
             prepareContext(context, environment, listeners, applicationArguments,printedBanner);
             // ⑦
              refreshContext(context);
             // ⑧
             afterRefresh(context, applicationArguments);
             // ⑨
             listeners.finished(context, null);
             stopWatch.stop();
             return context;
        }
         catch (Throwable ex) {
             handleRunFailure(context, listeners, analyzers, ex);
             throw new IllegalStateException(ex);
         }
     }
```

**① 通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners通过调用starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了。**

SpringApplicationRunListeners其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。

还记得初始化流程中，SpringApplication加载了一系列ApplicationListener吗？这个启动流程中没有发现有发布事件的代码，其实都已经在SpringApplicationRunListeners这儿实现了。

**② 创建并配置当前应用将要使用的Environment。**

Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：

配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。

因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。

总结起来，②处的两句代码，主要完成以下几件事：

判断Environment是否存在，不存在就创建（如果是web项目就创建StandardServletEnvironment，否则创建StandardEnvironment）

配置Environment：配置profile以及properties

调用SpringApplicationRunListener的environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好

**③SpringBoot应用在启动时会输出这样的东西**：

```shell
. ____          _            __ _ _
  /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \
 ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
  \\/ ___)| |_)| | | | | || (_| | ) ) ) )
   ' |____| .__|_| |_|_| |_\__, | / / / /
  =========|_|==============|___/=/_/_/_/
 :: Spring Boot :: (v1.5.6.RELEASE)
```

可以随意修改

**④、根据是否是web项目，来创建不同的ApplicationContext容器。**

**⑤、创建一系列FailureAnalyzer，创建流程依然是通过SpringFactoriesLoader获取到所有实现FailureAnalyzer接口的class，然后在创建对应的实例。FailureAnalyzer用于分析故障并提供相关诊断信息。**

**⑥、初始化ApplicationContext，主要完成以下工作：**

将准备好的Environment设置给ApplicationContext

遍历调用所有的ApplicationContextInitializer的initialize()方法来对已经创建好的ApplicationContext进行进一步的处理

调用SpringApplicationRunListener的contextPrepared()方法，通知所有的监听者：ApplicationContext已经准备完毕

将所有的bean加载到容器中

调用SpringApplicationRunListener的contextLoaded()方法，通知所有的监听者：ApplicationContext已经装载完毕

**⑦、调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。**

插手容器的启动，获取到所有的BeanFactoryPostProcessor来对容器进行一些额外的操作

**⑧、查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。**

**⑨、执行所有SpringApplicationRunListener的finished()方法。**

这就是Spring Boot的整个启动流程，其核心就是在Spring容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、ApplicationListener以及各种BeanFactoryPostProcessor等等。

# Spring Cloud

Spring Cloud是为了解决微服务架构的框架，传统系统开发根据不同的模块进行开发，但是由于不同模块之间存在一定的耦合，导致某一个模块出现bug，会影响到另一个模块；而SpringCloud中，每一个模块是一个独立的java进程，每个模块之间通过http请求进行通信（服务的注册与发现）

Eureka底层采用高可用架构模式（AP原则）

Zookeeper底层是为了保证数据一致性（CP原则）

## Eureka

Eureka是Netflix组件的一个子模块，也是核心模块之一。云端服务发现，一个基于 **REST（REpresentational State Transfer 表现层状态转移）** 的服务，用于定位服务，以实现云端中间层服务发现和故障转移

**REST**

用URL定位资源，用HTTP描述操作

### 工作流程

- Eureka客户端（以下简称客户端）启动后，定时向Eureka服务端（以下简称服务端）注册自己的服务信息（服务名、IP、端口等）；
- 客户端启动后，定时拉取服务端以保存的服务注册信息；
- 拉取服务端保存的服务注册信息后，就可调用消费其他服务提供者提供的服务。

### 客户端启动时如何注册到服务端

Eureka客户端在启动时，首先会创建一个心跳的定时任务（heartbeatExecutor线程池），定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息。

### 服务端如何保存客户端服务信息

客户端通过Jersey框架（亚马逊的一个http框架）将服务实例信息发送到服务端（register方法），服务端将客户端信息放在一个ConcurrentHashMap对象中。

### 客户端如何拉取服务端已保存的服务

客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取。

### 如何构建高可用的Eureka集群

- 建高可用的Eureka集群，只需要在注册中心的配置文件中配置其他注册中心的地址，配置属性如下：

  ```java
  eureka.client.service-url.defaultZone
  ```

- 注册中心收到注册信息后会判断是否是其他注册中心同步的信息还是客户端注册的信息（通过一个boolean变量 isReplication），如果是客户端注册的信息（false），那么他将会将该客户端信息同步到其他注册中心去；否则收到信息后不作任何操作。通过此机制避免集群中信息同步的死循环。

### 心跳和服务剔除机制

**心跳机制**

- 客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告诉服务端自己还活着，默认心跳的时间间隔是30s

**服务剔除机制**

- 如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务（即已过期的服务）都不会被剔除；
- 如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值（计算方法参考5.1节）比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制；
- 一旦服务剔除机制开启，则Eureka服务端并不会直接剔除所有已过期的服务，如果超过90s没有收到心跳信息则直接剔除服务

### 自我保护机制

首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。

默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。

**官方定义**

```shell
自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。
```

自我保护机制的工作机制是：**如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制**，此时会出现以下几种情况：

- Eureka Server不再从注册列表中移除  因为长时间没收到心跳而应该过期的服务。

- Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。

- 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。

**因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况**，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。

**自我保护机制开关**

Eureka自我保护机制，通过配置 `eureka.server.enable-self-preservation` 来`true`打开/`false`禁用自我保护机制，默认打开状态，建议生产环境打开此配置。

## Ribbon

Ribbon是Netflix发布的云中间层服务开源项目，其主要功能是提供客户端实现负载均衡算法。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，Ribbon是一个客户端负载均衡器，我们可以在配置文件中Load Balancer后面的所有机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器，我们也很容易使用Ribbon实现自定义的负载均衡算法。

### 如何使用Ribbon

上节示例中是使用RestTemplate进行Eureka Client(包括服务提供者以及服务消费者，在这里其实是服务消费者使用RestTemplate)之间的通信，为RestTemplate配置类添加@LoadBalanced注解即可，如下所示： 

```java
@Bean
@LoadBalanced
  public RestTemplate restTemplate() {
  return new RestTemplate();
}
```

### 包含的负载均衡算法

- RoundRobinRule 轮询

  **rest 接口第几次请求数 % 服务器集群总个数 = 实际调用服务器位置下标**，服务每次重启后 rest 请求数变为1

- RandomRule 随机

- AvailabilityFilteringRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数超过阈值的服务，然后对剩余的服务列表进行轮询

- WeightedResponseTimeRule 权重 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。刚启动时，如果统计信息不足，则使用轮询策略，等信息足够，切换到 WeightedResponseTimeRule

- RetryRule 重试 先按照轮询策略获取服务，如果获取失败则在指定时间内重试，获取可用服务

- BestAvailableRule 选过滤掉多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务

- ZoneAvoidanceRule 符合判断server所在区域的性能和server的可用性选择服务

### 如何自定义RibbonClient

#### 代码自定义

所谓的自定义Ribbon Client的主要作用就是使用自定义配置替代Ribbon默认的负载均衡策略，注意：自定义的Ribbon Client是有针对性的，一般一个自定义的Ribbon Client是对一个服务提供者(包括服务名相同的一系列副本)而言的。自定义了一个Ribbon Client 它所设定的负载均衡策略只对某一特定服务名的服务提供者有效，但不能影响服务消费者与别的服务提供者通信所使用的策略。根据官方文档的意思，推荐在 springboot主程序扫描的包范围之外进行自定义配置类。其实纯代码自定义RibbonClient的话有两种方式：

- 在springboot主程序扫描的包外定义配置类（防止对所有的Ribbon都生效），然后为springboot主程序添加@RibbonClient注解引入配置类 

  ```java
  @Configuration
  public class TestConfiguration {
      @Autowired
      private IClientConfig config;
      @Bean
      public IRule ribbonRule(IClientConfig config) { // 自定义为随机规则
          return new RandomRule();
      }
  }
  ```

- 在与springboot主程序的同一级目录新建RibbonClient的配置类，但是必须在springboot扫描的包范围内排除掉，方法是自定义注解标识配置类，然后在springboot的添加@ComponentScan根据自定义注解类型过滤掉配置类

  **自定义注解**

  ```java
  public @interface ExcludeFromComponentScan {
  }
  自定义配置类
  @Configuration
  @ExcludeFromComponentScan
  public class TestConfiguration1 {
      @Autowired
      private IClientConfig config;
      @Bean
      public IRule ribbonRule(IClientConfig config) { // 自定义为随机规则
          return new RandomRule();
      }
  }
  ```

  **在主程序上添加**

  ```java
  @RibbonClient(name = "microservice-provider-user",configuration = TestConfiguration1.class)
  @ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = ExcludeFromComponentScan.class)})
  ```

#### 配置文件自定义

创建配置类的方式虽然能够实现个性化定义，但是当有大量这类配置的时候，对各个RibbonClient 的配置信息都将分散在这些配置类中，使得修改和管理都变得非常麻烦。在Camden版本中，Spring Cloud Ribbon对 RibbonClient 的个性化配置做了进一步优化，可以通过.ribbon.=的形式进行配置。配置如下

```shell
#注册中心集群
eureka.client.service-url.defaultZone=http://10.25.25.92:8080/eureka/,http://10.25.25.24:8080/eureka/,http://10.25.25.39:8080/eureka/
server.port=8764
spring.application.name=service-ribbon
springboot-eureka-clent.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule
```

#### 不依赖eureka实现Ribbon负载均衡

```shell
#取消Ribbon使用Eureka
ribbon.eureka.enabled=false
#配置Ribbon能访问 的微服务节点，多个节点用逗号隔开
microservice-provider-user.ribbon.listOfServers=localhost:8001，localhost:8002
```

## Hystrix

- 源自Martin Fowler的Circuit Breaker，即断路器。“断路器”本身是一种开关装置，用于线路上的过载保护，当线路发生短路时，会及时切断故障电路，防止一系列问题。
- 在分布式架构中，断路器模式也是类似，当某个单元发生故障，及时切断联系，防止线程因调用故障服务而长时间等待而不被释放，最终导致故障在分布式系统中的蔓延。
- Hystrix实现的功能有：服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并、以及服务监控等功能。（**对于请求缓存功能，个人建议不要使用，除非该实例是单机运行，否则会出现数据不一致的问题**）

### 什么是服务雪崩

多个服务之间调用的时候，假设服务A调用服务B和服务C，服务B和服务C又调用其他的服务，这就是所谓的“扇出”。如果“扇出”的链路上某个服务调用响应时间过长或者不可用，对服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的 “ 雪崩效应 ”。

所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接受流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫 雪崩。

要避免这样的级联故障，就需要有一种链路中断的方案：
**服务降级、服务熔断**

### 服务降级 熔断 限流

- **服务降级**

  服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。
  **哪些情况会发出降级？**

  - 程序运行异常
  - 超时
  - 服务熔断触发服务降级
  - 线程池 / 信号量打满也会导致服务降级

- **服务熔断**

  服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。

- **服务限流**

  秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行

**熔断VS降级**

**相同点：**

目标一致 都是从可用性和可靠性出发，为了防止系统崩溃；

用户体验类似 最终都让用户体验到的是某些功能暂时不可用；

**不同点：**

触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；

### 使用方式

在启动类配置的注解为

```java
@EnableHystrix
```

业务代码为

```java
@GetMapping("/consumer/payment/hystrix/timeout/{id}")
    @HystrixCommand(fallbackMethod = "paymentTimeOutFallBackMethod", commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
    })
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) {
        return paymentHystrixService.paymentInfo_TimeOut(id);
    }
```

配置文件为

```java
feign.hystrix.enable=true
```

## Zuul

Zuul是spring cloud中的微服务网关。网关： 是一个网络整体系统中的前置门户入口。请求首先通过网关，进行路径的路由，定位到具体的服务节点上。

Zuul是一个微服务网关，首先是一个微服务。也是会在Eureka注册中心中进行服务的注册和发现。也是一个网关，请求应该通过Zuul来进行路由。

Zuul网关不是必要的。是推荐使用的。

使用Zuul，一般在微服务数量较多（多于10个）的时候推荐使用，对服务的管理有严格要求的时候推荐使用，当微服务权限要求严格的时候推荐使用。

### 网关的作用

- 统一入口：未全部为服务提供一个唯一的入口，网关起到外部和内部隔离的作用，保障了后台服务的安全性。
- 鉴权校验：识别每个请求的权限，拒绝不符合要求的请求。
- 动态路由：动态的将请求路由到不同的后端集群中。
- 减少客户端与服务端的耦合：服务可以独立发展，通过网关层来做映射。

### 网关的启动与应用

**启动**

```java
/**
 * @EnableZuulProxy - 开启Zuul网关。
 *  当前应用是一个Zuul微服务网关。会在Eureka注册中心中注册当前服务。并发现其他的服务。
 *  Zuul需要的必要依赖是spring-cloud-starter-zuul。
 */
@SpringBootApplication
@EnableZuulProxy
public class ZuulApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class, args);
    }
}
```

### 网关配置

**URL路径配置**

```shell
# URL pattern
# 使用路径方式匹配路由规则。
# 参数key结构： zuul.routes.customName.path=xxx
# 用于配置路径匹配规则。
# 其中customName自定义。通常使用要调用的服务名称，方便后期管理
# 可使用的通配符有： * ** ?
# ? 单个字符
# * 任意多个字符，不包含多级路径
# ** 任意多个字符，包含多级路径
zuul.routes.eureka-application-service.path=/api/**
# 参数key结构： zuul.routes.customName.url=xxx
# url用于配置符合path的请求路径路由到的服务地址。
zuul.routes.eureka-application-service.url=http://127.0.0.1:8080/
```

**服务名称匹配**

```shell
# service id pattern 通过服务名称路由
# key结构 ： zuul.routes.customName.path=xxx
# 路径匹配规则
zuul.routes.eureka-application-service.path=/api/**
# key结构 ： zuul.routes.customName.serviceId=xxx
# serviceId用于配置符合path的请求路径路由到的服务名称。
zuul.routes.eureka-application-service.serviceId=eureka-application-service


# simple service id pattern 简化配置方案
# 如果只配置path，不配置serviceId。则customName相当于服务名称。
# 符合path的请求路径直接路由到customName对应的服务上。
zuul.routes.eureka-application-service.path=/api/**
```

**路由排除配置**

```shell
# ignored service id pattern
# 配置不被zuul管理的服务列表。多个服务名称使用逗号','分隔。
# 配置的服务将不被zuul代理。
zuul.ignored-services=eureka-application-service

# 此方式相当于给所有新发现的服务默认排除zuul网关访问方式，只有配置了路由网关的服务才可以通过zuul网关访问
# 通配方式配置排除列表。
zuul.ignored-services=*
# 使用服务名称匹配规则配置路由列表，相当于只对已配置的服务提供网关代理。
zuul.routes.eureka-application-service.path=/api/**

# 通配方式配置排除网关代理路径。所有符合ignored-patterns的请求路径都不被zuul网关代理。
zuul.ignored-patterns=/**/test/**
zuul.routes.eureka-application-service.path=/api/**
```

**路由前缀配置**

```shell
# prefix URL pattern 前缀路由匹配
# 配置请求路径前缀，所有基于此前缀的请求都由zuul网关提供代理。
zuul.prefix=/api
# 使用服务名称匹配方式配置请求路径规则。
# 这里的配置将为：http://ip:port/api/appservice/**的请求提供zuul网关代理，可以将要访问服务进行前缀分类。
# 并将请求路由到服务eureka-application-service中。
zuul.routes.eureka-application-service.path=/appservice/**
```

### 网关过滤器

Zuul中提供了过滤器定义，可以用来过滤代理请求，提供额外功能逻辑。如：权限验证，日志记录等。

**Zuul提供的过滤器是一个父类。父类是ZuulFilter。通过父类中定义的抽象方法filterType，来决定当前的Filter种类是什么。**有前置过滤、路由后过滤、后置过滤、异常过滤。

- **前置过滤**：是请求进入Zuul之后，立刻执行的过滤逻辑。
- **路由后过滤**：是请求进入Zuul之后，并Zuul实现了请求路由后执行的过滤逻辑，路由后过滤，是在远程服务调用之前过滤的逻辑。
- **后置过滤**：远程服务调用结束后执行的过滤逻辑。
- **异常过滤**：是任意一个过滤器发生异常或远程服务调用无结果反馈的时候执行的过滤逻辑。无结果反馈，就是远程服务调用超时。

## Config

```shell
Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。
```

### 配置说明

#### 服务端

首先是服务端这块，首先创建一个注册中心，为了进行区分，创建一个`springcloud-config-eureka`的项目。 代码和配置和之前的基本一样。applicatioon.properties添加配置信息

```shell
spring.application.name=springcloud-hystrix-eureka-server
server.port=8005
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:8005/eureka/
```

- [spring.application.name](http://spring.application.name/)： 这个是指定服务名称。
- server.port:服务指定的端口。
- eureka.client.serviceUrl.defaultZone： 这个是设置与Eureka Server交互的地址，客户端的查询服务和注册服务都需要依赖这个地址。
- spring.cloud.config.server.git.uri: 配置的Git长裤的地址。
- spring.cloud.config.server.git.search-paths: git仓库地址下的相对地址 多个用逗号","分割。
- spring.cloud.config.server.git.username:git仓库的账号。
- spring.cloud.config.server.git.password:git仓库的密码。

**注:如果想使用本地方式读取配置信息，那么只需将`spring.cloud.config.server.git`的配置改成`spring.profiles.active=native`，然后在resources路径下新增一个文件即可。**

启动配置就直接在程序主类中添加**@EnableConfigServer**注解，表示启用config配置中心功能

#### 客户端

我们新建一个`springcloud-config-client`的项目，用于做读取配置中心的配置。pom依赖还是和配置中心一样，不过需要新增一个配置，用于指定配置的读取。
创建一个`bootstrap.properties`文件，并添加如下信息:

```shell
spring.cloud.config.name=configtest
spring.cloud.config.profile=pro
spring.cloud.config.label=master
spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.serviceId=springcloud-config-server
eureka.client.serviceUrl.defaultZone=http://localhost:8005/eureka/
```

- [spring.cloud.config.name](http://spring.cloud.config.name/)： 获取配置文件的名称。
- spring.cloud.config.profile: 获取配置的策略。
- spring.cloud.config.label：获取配置文件的分支，默认是master。如果是是本地获取的话，则无用。
- spring.cloud.config.discovery.enabled: 开启配置信息发现。
- spring.cloud.config.discovery.serviceId: 指定配置中心的service-id，便于扩展为高可用配置集群。
- eureka.client.serviceUrl.defaultZone： 这个是设置与Eureka Server交互的地址，客户端的查询服务和注册服务都需要依赖这个地址。

**注**:上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为bootstrap.properties的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。需要注意的是`eureka.client.serviceUrl.defaultZone`要配置在bootstrap.properties，不然客户端是无法获取配置中心参数的，会启动失败！

**application.properties配置**

```shell
spring.application.name=springcloud-config-client
server.port=9006
```

# MyBatis

**概念**

- Mybatis是一个半ORM（对象关系映射），它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要再花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。 

- Mybatis可以使用XML或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。

**优点**

- 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理。提供xml标签，支持编写动态SQL语句，并可重用。
- 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
- 很好的与各种数据库兼容（因为Mybatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。
- 能够与Spring很好的集成。

**缺点**

- SQL语句的编写工作量较大，尤其当字段多、关联表多时，编写SQL语句的功底有一定要求。
- SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

## #{}和\${}的区别是什么？

- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如\${driver}会被静态替换为`com.mysql.jdbc.Driver`。
- `#{}`是 sql 的参数占位符，Mybatis 会将 sql 中的`#{}`替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，`#{item.name}` 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 `param.getItem().getName()`。

## 一级缓存和二级缓存

- 一级缓存 Mybatis的一级缓存是指SQLSession，一级缓存的作用域是SQlSession, Mybits默认开启一级缓存。 在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空。 每次查询会先去缓存中找，如果找不到，再去数据库查询，然后把结果写到缓存中。 Mybatis的内部缓存使用一个HashMap，key为hashcode+statementId+sql语句。Value为查询出来的结果集映射成的java对象。 SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。

- 二级缓存是mapper级别的，Mybatis默认是没有开启二级缓存的。 第一次调用mapper下的SQL去查询用户的信息，查询到的信息会存放代该mapper对应的二级缓存区域。 第二次调用namespace下的mapper映射文件中，相同的sql去查询用户信息，会去对应的二级缓存内取结果。 如果调用相同namespace下的mapepr映射文件中增删改sql，并执行了commit操作

**一级缓存：**也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。

**二级缓存：**也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。

## Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

还有很多其他的标签，`<resultMap>`、`<parameterMap>`、`<sql>`、`<include>`、`<selectKey>`，加上动态 sql 的 9 个标签，`trim|where|set|foreach|if|choose|when|otherwise|bind`等，其中<sql>为 sql 片段标签，通过`<include>`标签引入 sql 片段，`<selectKey>`为不支持自增的主键生成策略标签。

## DAO接口的工作原理

Dao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 sql 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.mybatis3.mappers.StudentDao.findStudentById`，可以唯一找到 namespace 为`com.mybatis3.mappers.StudentDao`下面`id = findStudentById`的`MappedStatement`。在 Mybatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象。

Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao 接口的工作原理是 JDK 动态代理，Mybatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行`MappedStatement`所代表的 sql，然后将 sql 执行结果返回。

## MyBatis分页以及原理

Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：`select _ from student`，拦截 sql 后重写为：`select t._ from （select \* from student）t limit 0，10`

## MyBatis插件运行原理

Mybatis 仅可以编写针对 `ParameterHandler`、`ResultSetHandler`、`StatementHandler`、`Executor` 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 `InvocationHandler` 的 `invoke()`方法，当然，只会拦截那些你指定需要拦截的方法。

实现 Mybatis 的 Interceptor 接口并复写` intercept()`方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

## 动态sql与执行原理

Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，Mybatis 提供了 9 种动态 sql 标签 `trim|where|set|foreach|if|choose|when|otherwise|bind`。

其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

## Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用`<resultMap>`标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。

有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

## Mybatis 执行一对一、一对多查询的实现方式与区别

Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 `selectOne()`修改为 `selectList()`即可；多对多查询，其实就是一对多查询，只需要把 `selectOne()`修改为 `selectList()`即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是`<resultMap>`标签内的`<id>`子标签，指定了唯一确定一条记录的 id 列，Mybatis 根据<id>列值来完成 100 条记录的去重复功能，`<id>`可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，Mybatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

 t_id t_name s_id

| 1 | teacher | 38 |
| 1 | teacher | 39 |
| 1 | teacher | 40 |
| 1 | teacher | 41 |
| 1 | teacher | 42 |
| 1 | teacher | 43 |

## 延迟加载与实现原理

**延迟加载：**在真正使用数据时才发起查询，不用的时候不查询，按需加载

**立即加载：**不管用不用，只要一调用方法，马上发起查询

Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 `lazyLoadingEnabled=true|false。`

**原理：**使用` CGLIB` 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 `a.getB().getName()`，拦截器 `invoke()`方法发现 `a.getB()`是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 `a.getB().getName()`方法的调用。这就是延迟加载的基本原理。

当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。

## Mybatis 中的Executor 执行器

Mybatis 有三种基本的 Executor 执行器，**`SimpleExecutor`、`ReuseExecutor`、`BatchExecutor`。**

**`SimpleExecutor`：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

**`ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

**`BatchExecutor`：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

在 Mybatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 `DefaultSqlSessionFactory` 的创建 SqlSession 的方法传递 ExecutorType 类型参数。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

## Mybatis 映射 Enum 枚举类

Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 `TypeHandler`，实现 `TypeHandler` 的 `setParameter()`和 `getResult()`接口方法。`TypeHandler` 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 `setParameter()`和 `getResult()`两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。

## MyBatis标签解析

虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。

**原理：**Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。

## Xml 映射文件和 Mybatis 内部数据结构之间的映射关系

Mybatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，`<parameterMap>`标签会被解析为 `ParameterMap` 对象，其每个子元素会被解析为 ParameterMapping 对象。`<resultMap>`标签会被解析为 `ResultMap` 对象，其每个子元素会被解析为 `ResultMapping` 对象。每一个`<select>、<insert>、<update>、<delete>`标签均会被解析为 `MappedStatement` 对象，标签内的 sql 会被解析为 BoundSql 对象。

## 为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 Mybatis 系列博客中都有详细讲解和原理分析。

# Docker

## 什么是docker

Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。

## docker与虚拟机的区别

Docker不是虚拟化方法。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。为此，Docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。

- 容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取。
- 由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能。
- 对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件。
- 主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。
- 与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发。
- 容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似。

## 什么是docker镜像

Docker镜像是Docker容器的源代码，Docker镜像用于创建容器。使用build命令创建镜像。

## 什么是docker容器

Docker容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。

## docker容器有几种状态

四种状态：运行、已暂停、重新启动、已退出。

## docker常用命令

docker pull 拉取或者更新指定镜像
docker push 将镜像推送至远程仓库
docker rm 删除容器
docker rmi 删除镜像
docker images 列出所有镜像
docker ps 列出所有容器

## dockerfile中常见的指令

```
Dockerfile中的一些常用指令如下：
FROM：指定基础镜像
LABEL：功能是为镜像指定标签
RUN：运行指定的命令
CMD：容器启动时要运行的命令
```

## docker的优点

**1.更高效的利用系统资源**

docker对系统资源的利用率更高，无论是应用执行速度，内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机往往可以运行更多数量的应用。

**2.更快速的启动时间**

传统的虚拟机技术启动应用服务往往需要数分钟，而docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级，甚至毫秒级的启动时间，大大的节约了开发测试，部署的时间。

**3.一致的运行环境**

开发过程中常见的一个问题是环境一致问题，由于开发环境，测试环境，生产环境不一致，导致有些bug并未在开发过程中发现。而docker的镜像提供了除内核外完整的运行时环境，确保环境一致性，从而不会在出现“这段代码在我机器上没问题”这类问题。

**4.持续支付和部署**

对开发和运维人员来说，最希望就是一次创建和部署，可以在任意的地方运行。（定制应用镜像来实现集成、持续支付、部署。开发人员可以通过**dockerfile**来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署）。而且使用**dockerfile**使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。

**5.更轻松的迁移**

由于docker确保了执行环境的一致性，使得应用的迁移更加的容易。docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云、甚至是笔记本、其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。

**6.更轻松的维护和拓展**

docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得十分简单。此外，docker团队同各个开源项目团队一起维护了一大批高质量的官网镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。

# 项目

## 认证授权如何实现

Spring security + Oauth2完成用户认证及用户授权。认证授权流程如下：
1、用户请求认证服务完成身份认证。
2、认证服务下发用户身份令牌和JWT令牌，拥有身份令牌表示身份合法，Jwt令牌用于完成授权。
3、用户携带jwt令牌请求资源服务。
4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。
5、资源服务获取jwt令牌，根据jwt令牌完成授权

## 认证与授权实现思路

如果系统的模块多，每个模块都需要就行授权与认证，所以选择基于token的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key，权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问

## 项目一

- 在编写shiroFilter过滤链的时候，/user/**要尽量放在filter链路的后面，不然登录方法可能会被强行拦截
- 项目前后端通信通过json来实现，前端发送ajax请求，在处理过程中被后端异常拦截，再返还给前端，利用前端框架展示错误，避免出现抛出异常前端直接页面跳转导致的用户体验不佳的问题
- 本地使用Ehcache缓存，在登录注册subject的时候使用的是username不是user，在修改账号密码删除缓存的时候也是删除username，之前删除缓存不一致，导致账号密码修改之后一直无法登录
- 使用thymeleaf-Shiro进行开发，后端发送用户权限信息，前端对于用户权限进行拦截，保护关键的Uri隐藏
- 开发文件分片上传的时候，先发送一个ajax请求确认文件是否已经上传了，然后再分片进行上传，防止文件重复传输
- 文件上传使用混合加密，后端生成rsa密钥对，给前端发送rsa公钥，前端生成aes密钥（aes密钥用来加密文件分片），用rsa公钥给aes密钥加密，发送给后端，后端利用rsa私钥解密aes密钥获取到aes密钥，aes密钥再解出文件分片
- 在进行文件分片byte to string的时候 使用toHexString方法可以保证文件在转换的过程中不乱码，如果使用toString可能会导致文件数据丢失

## 项目二

- 前后端分离开发需要考虑跨域问题，需要在Vue中配置跨域转发，否则会导致Uri无法找到的问题
- 在配置Redis哨兵机制的时候，对于每一个slave或者master都需要配置独立的redis.conf
- 在给网站用户配置一个登录无操作下线时间20分钟，如果是20分钟无操作强制下线，如果有操作再叠加20分钟，jwt的过期时间放在redis里面，一旦有操作就对于redis的过期时间进行修改

# 手撕算法

## 字符串

### 翻转单词顺序

```java
/**
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。**/
//时间空间复杂度O(n)
class Solution {
    public String reverseWords(String s) {
        s = s.trim(); // 删除首尾空格
        int j = s.length() - 1, i = j;
        StringBuilder res = new StringBuilder();
        while(i >= 0) {
            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格
            res.append(s.substring(i + 1, j + 1) + " "); // 添加单词
            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格
            j = i; // j 指向下个单词的尾字符
        }
        return res.toString().trim(); // 转化为字符串并返回
    }
}
//时间空间复杂度O(n)
class Solution {
    public String reverseWords(String s) {
        String[] strs = s.trim().split(" "); // 删除首尾空格，分割字符串
        StringBuilder res = new StringBuilder();
        for(int i = strs.length - 1; i >= 0; i--) { // 倒序遍历单词列表
            if(strs[i].equals("")) continue; // 遇到空单词则跳过
            res.append(strs[i] + " "); // 将单词拼接至 StringBuilder
        }
        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回
    }
}

```

### 无重复字符的最长子串

``` java
//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 
//
// 示例 1: 
//
// 输入: "abcabcbb"
//输出: 3 
//解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 
//
// 示例 2: 
//
// 输入: "bbbbb"
//输出: 1
//解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
// 
//
// 示例 3: 
//
// 输入: "pwwkew"
//输出: 3
//解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
//     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
// 
// Related Topics 哈希表 双指针 字符串 Sliding Window 
// 👍 4091 👎 0
//双指针+哈希表
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0) return 0;
        int lo = 0;
        int hi = 1;
        int res = 1;
        Map<Character, Integer> map = new HashMap<>();
        map.put(s.charAt(lo), 0);
        while(hi < s.length()){
            Integer index = map.get(s.charAt(hi));
            if(index != null && index >= lo){
                lo = index + 1;
            }
            map.put(s.charAt(hi), hi);
            res = Math.max(res, hi - lo + 1);
            hi++;
        }
        return res;
    }
//leetcode submit region end(Prohibit modification and deletion)
}

//动态规划+哈希表 时间复杂度 O(n)  空间复杂度O(1)
//哈希表统计： 遍历字符串 ss 时，使用哈希表（记为 dicdic ）统计 各字符最后一次出现的索引位置 。
//左边界 i 获取方式： 遍历到 s[j]s[j] 时，可通过访问哈希表 dic[s[j]]dic[s[j]] 获取最近的相同字符的索引 i。

class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int res = 0, tmp = 0;
        for(int j = 0; j < s.length(); j++) {
            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
            dic.put(s.charAt(j), j); // 更新哈希表
            tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        }
        return res;
    }
}
```

### 最长回文子串

``` java
//给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 
//
// 示例 1： 
//
// 输入: "babad"
//输出: "bab"
//注意: "aba" 也是一个有效答案。
// 
//
// 示例 2： 
//
// 输入: "cbbd"
//输出: "bb"
// 
// Related Topics 字符串 动态规划 
// 👍 2513 👎 0
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() == 0) return "";
        boolean[][] dp = new boolean[s.length()][s.length()];
        int left = 0;
        int right = 0;
        for(int i = s.length() - 1; i >=0; i--){
            dp[i][i] = true;
            for(int j = i + 1; j < s.length(); j++){
                if(s.charAt(i) == s.charAt(j) && (dp[i + 1][j - 1] || j - i == 1)){
                    dp[i][j] = true;
                }else{
                    dp[i][j] = false;
                }
                if(dp[i][j] && (j - i > right - left)){
                    right = j;
                    left = i;
                }
            }
        }
        return s.substring(left, right + 1);
    }
}
```

### 分割回文串

```java
//给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 
//
// 返回 s 所有可能的分割方案。 
//
// 示例: 
//
// 输入: "aab"
//输出:
//[
//  ["aa","b"],
//  ["a","a","b"]
//] 
// Related Topics 回溯算法 
// 👍 344 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public List<List<String>> partition(String s) {
        int len = s.length();
        List<List<String>> res = new ArrayList<>();
        if (len == 0){
            return res;
        }
        //判断是否回文
        boolean[][] dp = new boolean[len][len];
        for(int i = s.length() - 1; i >=0; i--){
            dp[i][i] = true;
            for(int j = i + 1; j < s.length(); j++){
                if(s.charAt(i) == s.charAt(j) && (dp[i + 1][j - 1] || j - i == 1)){
                    dp[i][j] = true;
                }else{
                    dp[i][j] = false;
                }
            }
        }
        List<String> list = new ArrayList<>();
        helper(s, 0, len, dp, list, res);
        return res;
    }

    public void helper(String s, int start, int len, boolean[][] dp, List<String> list, List<List<String>> res){
        if(start >= len){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i = start; i < len; i++){
            if(!dp[start][i]){
                //如果不是回文的，直接跳出本次循环
                continue;
            }
            list.add(s.substring(start, i + 1));
            helper(s, i + 1, len, dp, list, res);
            list.remove(list.size() - 1);
        }
    }
}
//leetcode submit region end(Prohibit modification and deletion)
}
```

```java
12//分割回文串的次数     
  static int minCut(String str) {
13         int len = str.length();
14         int[] f = new int[len+1]; //最小分割的数组
15         int[][] dp = new int[len][len]; //动态规划实现回文字符串判断
16         /*
17          * 初始化最坏情况  每一个字符串都作为单独的一个字符串作为回文字符串  这个时候f[0] = n-1-0
18          * 需要n-1次切割  后续相同
19          */
20         for (int i = 0; i <= len; i++) {
21             f[i] = len - 1 -i;
22         }
23         for (int i = len - 1; i >= 0; i--) {
24             dp[i][i] = 1;
25             for (int j = i; j < len; j++) {
26                 if(str.charAt(i) == str.charAt(j) && ((j - i < 2) || dp[i+1][j-1] == 1)) {
27                     dp[i][j] = 1;
28                     f[i] = Math.min(f[i], f[j+1]+1);
29                 }                
30             }
31         }
32         return f[0];
33     }
```

### 字符串的排列

```java
//输入一个字符串，打印出该字符串中字符的所有排列。 
//
// 
//
// 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 
//
// 
//
// 示例: 
//
// 输入：s = "abc"
//输出：["abc","acb","bac","bca","cab","cba"]
// 
//
// 
//
// 限制： 
//
// 1 <= s 的长度 <= 8 
// Related Topics 回溯算法 
// 👍 79 👎 0
//时间复杂度 O(N!) 空间复杂度O(N^2)
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
        char[] c;
        List<String> res = new ArrayList<>();
    public String[] permutation(String s) {
        c = s.toCharArray();
        solve(c, 0, c.length - 1);
        return res.toArray(new String[res.size()]);
    }

    public void solve(char[] c, int start, int end){
        if(start == end){
            res.add(String.valueOf(c));
        }
        Set<Character> set = new HashSet<>();
        for(int i = start; i <= end; i++){
            if(set.contains(c[i])) continue;
            set.add(c[i]);
            swap(c, i, start);
            solve(c, start + 1, end);
            swap(c, start, i);
        }
    }
    public void swap(char[] c, int i, int j){
        char tmp = c[i];
        c[i] = c[j];
        c[j] = tmp;
    }
}
```

### 验证回文串

```java
//给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 
//
// 说明：本题中，我们将空字符串定义为有效的回文串。 
//
// 示例 1: 
//
// 输入: "A man, a plan, a canal: Panama"
//输出: true
// 
//
// 示例 2: 
//
// 输入: "race a car"
//输出: false
// 
// Related Topics 双指针 字符串 
// 👍 258 👎 0
class Solution {
    public boolean isPalindrome(String s) {
        char[] c = s.toCharArray();
        int lo = 0;
        int hi = s.length() - 1;
        while(lo < hi){
            if(!Character.isLetterOrDigit(c[lo])){
                lo++;
            }else if(!Character.isLetterOrDigit(c[hi])){
                hi--;
            }else{
                if(Character.toLowerCase(c[lo]) == Character.toLowerCase(c[hi])){
                    lo++;
                    hi--;
                }else{
                    return false;
                }
            }
        }
        return true;
    }
}
```

### 把数字翻译成字符串

```java
/**
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。


示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
**/
class Solution {
    public int translateNum(int num) {
        char[] s = String.valueOf(num).toCharArray();;
        int[] dp = new int[s.length + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= s.length; i++){
            int tmp = Integer.parseInt(s[i - 2] + "" + s[i - 1]);
            if(tmp < 26 && tmp > 9){
                dp[i] = dp[i - 2] + dp[i - 1];
            }else{
                dp[i] = dp[i - 1];
            }
        }
        return dp[s.length];
    }
}
```

### 字符串解码

```java
//一条包含字母 A-Z 的消息通过以下方式进行了编码： 
//
// 'A' -> 1
//'B' -> 2
//...
//'Z' -> 26
// 
//
// 给定一个只包含数字的非空字符串，请计算解码方法的总数。 
//
// 示例 1: 
//
// 输入: "12"
//输出: 2
//解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
// 
//
// 示例 2: 
//
// 输入: "226"
//输出: 3
//解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
// 
// Related Topics 字符串 动态规划 
// 👍 462 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public int numDecodings(String s) {
        int len = s.length();
        if(len == 0) return 0;
        int[] dp = new int[len];
        char[] c = s.toCharArray();
        if(c[0] == '0') return 0;
        dp[0] = 1;
        for(int i = 1; i < len; i++){
            if(c[i] != '0') dp[i] = dp[i - 1];
            int num = 10 * (c[i - 1] - '0') + (c[i] - '0');
            if(num >= 10 && num <= 26){
                if(i == 1){
                    dp[i]++;
                }else{
                    dp[i] += dp[i - 2];
                }
            }
        }
        return dp[len - 1];
    }
}
```

### 最长公共前缀

```java
//编写一个函数来查找字符串数组中的最长公共前缀。 
//
// 如果不存在公共前缀，返回空字符串 ""。 
//
// 示例 1: 
//
// 输入: ["flower","flow","flight"]
//输出: "fl"
// 
//
// 示例 2: 
//
// 输入: ["dog","racecar","car"]
//输出: ""
//解释: 输入不存在公共前缀。
// 
//
// 说明: 
//
// 所有输入只包含小写字母 a-z 。 
// Related Topics 字符串 
// 👍 1196 👎 0
package com.sheva.leetcode.editor.cn;
import java.util.*;
public class LongestCommonPrefix {
    public static void main(String[] args) {
        Solution solution = new LongestCommonPrefix().new Solution();
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0) return "";
        int len = strs[0].length();
        for(int i = 0; i < len; i++){
            char tmp = strs[0].charAt(i);
            for(int j = 1; j < strs.length; j++){
                if(i == strs[j].length() || strs[j].charAt(i) != tmp){
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
//leetcode submit region end(Prohibit modification and deletion)
}
```

### 电话号码的字符组合

```java
//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 
//
// 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 
//
// 
//
// 示例: 
//
// 输入："23"
//输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
// 
//
// 说明: 
//尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 
// Related Topics 字符串 回溯算法 
// 👍 822 👎 0

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public List<String> letterCombinations(String digits) {
            List<String> res = new ArrayList<>();
            if (digits == null || digits.length() == 0) return res;
            permute(res, digits, new StringBuilder());
            return res;
        }
        private void permute(List<String> res, String digits, StringBuilder sb) {
            if (digits.length() == 0) {
                res.add(sb.toString());
                return;
            }
            for (char c : getChars(digits.charAt(0))) {
                sb.append(c);
                permute(res, digits.substring(1), sb);
                sb.deleteCharAt(sb.length() - 1); // 回溯主要体现在这部分
            }
        }
        private char[] getChars(char c) {
            switch(c){
                case '2':
                    return new char[]{'a', 'b', 'c'};
                case '3':
                    return new char[]{'d', 'e', 'f'};
                case '4':
                    return new char[]{'g', 'h', 'i'};
                case '5':
                    return new char[]{'j', 'k', 'l'};
                case '6':
                    return new char[]{'m', 'n', 'o'};
                case '7':
                    return new char[]{'p', 'q', 'r', 's'};
                case '8':
                    return new char[]{'t', 'u', 'v'};
                case '9':
                    return new char[]{'w', 'x', 'y', 'z'};
                default:
                    return new char[0];
            }
        }
    }
}
```

### 单词拆分

```java
//给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 
//
// 说明： 
//
// 
// 拆分时可以重复使用字典中的单词。 
// 你可以假设字典中没有重复的单词。 
// 
//
// 示例 1： 
//
// 输入: s = "leetcode", wordDict = ["leet", "code"]
//输出: true
//解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
// 
//
// 示例 2： 
//
// 输入: s = "applepenapple", wordDict = ["apple", "pen"]
//输出: true
//解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
//     注意你可以重复使用字典中的单词。
// 
//
// 示例 3： 
//
// 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
//输出: false
// 
// Related Topics 动态规划 
// 👍 611 👎 0
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for(int i = 1; i <= s.length(); i++){
            for(int j = 0; j < i; j++){
                if(dp[j] && set.contains(s.substring(j, i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

### 字符串转整数

```java
//请你来实现一个 atoi 函数，使其能将字符串转换成整数。 
//
// 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 
//
// 
// 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 
// 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 
// 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 
// 
//
// 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 
//
// 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 
//
// 提示： 
//
// 
// 本题中的空白字符只包括空格字符 ' ' 。 
// 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231
// − 1) 或 INT_MIN (−231) 。 
// 
//
// 
//
// 示例 1: 
//
// 输入: "42"
//输出: 42
// 
//
// 示例 2: 
//
// 输入: "   -42"
//输出: -42
//解释: 第一个非空白字符为 '-', 它是一个负号。
//     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
// 
//
// 示例 3: 
//
// 输入: "4193 with words"
//输出: 4193
//解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
// 
//
// 示例 4: 
//
// 输入: "words and 987"
//输出: 0
//解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
//     因此无法执行有效的转换。 
//
// 示例 5: 
//
// 输入: "-91283472332"
//输出: -2147483648
//解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
//     因此返回 INT_MIN (−231) 。
// 
// Related Topics 数学 字符串 
// 👍 776 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
public class StringToIntegerAtoi {
    public static void main(String[] args) {
        Solution solution = new StringToIntegerAtoi().new Solution();
        String str = new String("    -42");
        System.out.println(solution.myAtoi(str));
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int myAtoi(String str) {
        if(str == null || str.length() == 0) return 0;
        char[] c = str.toCharArray();
        System.out.println("测试字符串的长度为：" + c.length);
        int len = c.length;
        int index = 0;
        while(index < len && c[index] == ' '){
            index++;
        }
        if(index == len){
            return 0;
        }
        boolean isNegative = false;
        if(c[index] == '-'){
            isNegative = true;
            index++;
        }else if(c[index] == '+'){
            index++;
        }else if(!Character.isDigit(c[index])){
            return 0;
        }
        int res = 0;
        while(index < len && Character.isDigit(c[index])){
            int digit = c[index] - '0';
            if(res > (Integer.MAX_VALUE - digit) / 10){
                return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            res = res * 10 + digit;
            index++;
        }
        return isNegative ? -res : res;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
}
```

### 编辑距离

```java
import java.util.Arrays;

public class Solution {

    public int minDistance(String word1, String word2) {
        // 由于 word1.charAt(i) 操作会去检查下标是否越界，因此
        // 在 Java 里，将字符串转换成字符数组是常见额操作

        char[] word1Array = word1.toCharArray();
        char[] word2Array = word2.toCharArray();

        int len1 = word1Array.length;
        int len2 = word2Array.length;

        // 多开一行一列是为了保存边界条件，即字符长度为 0 的情况，这一点在字符串的动态规划问题中比较常见
        int[][] dp = new int[len1 + 1][len2 + 1];

        // 初始化：当 word 2 长度为 0 时，将 word1 的全部删除
        for (int i = 1; i <= len1; i++) {
            dp[i][0] = i;
        }
        // 当 word1 长度为 0 时，就插入所有 word2 的字符
        for (int j = 1; j <= len2; j++) {
            dp[0][j] = j;
        }

        // 注意：填写 dp 数组的时候，由于初始化多设置了一行一列，横、纵坐标有个偏移
        for (int i = 0; i < len1; i++) {
            for (int j = 0; j < len2; j++) {
                // 这是最佳情况
                if (word1Array[i] == word2Array[j]) {
                    dp[i + 1][j + 1] = dp[i][j];
                    continue;
                }
                // 否则在以下三种情况中选出步骤最少的，这是「动态规划」的「最优子结构」
                // 1、在下标 i 处插入一个字符
                int insert = dp[i + 1][j] + 1;
                // 2、替换一个字符
                int replace = dp[i][j] + 1;
                // 3、删除一个字符
                int delete = dp[i][j + 1] + 1;
                dp[i + 1][j + 1] = Math.min(Math.min(insert, replace), delete);

            }
        }
        // 打印状态表格进行调试
//        for (int i = 0; i <=len1; i++) {
//            System.out.println(Arrays.toString(dp[i]));
//        }
        return dp[len1][len2];
    }
```





## 数组

### 回溯

#### 组合总和

```java
//给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 
//
// candidates 中的数字可以无限制重复被选取。 
//
// 说明： 
//
// 
// 所有数字（包括 target）都是正整数。 
// 解集不能包含重复的组合。 
// 
//
// 示例 1： 
//
// 输入：candidates = [2,3,6,7], target = 7,
//所求解集为：
//[
//  [7],
//  [2,2,3]
//]
// 
//
// 示例 2： 
//
// 输入：candidates = [2,3,5], target = 8,
//所求解集为：
//[
//  [2,2,2,2],
//  [2,3,3],
//  [3,5]
//] 
//
// 
//
// 提示： 
//
// 
// 1 <= candidates.length <= 30 
// 1 <= candidates[i] <= 200 
// candidate 中的每个元素都是独一无二的。 
// 1 <= target <= 500 
// 
// Related Topics 数组 回溯算法 
// 👍 795 👎 0

package com.sheva.leetcode.editor.cn;
import com.sun.tools.corba.se.idl.InterfaceGen;

import java.util.*;
public class CombinationSum{
    public static void main(String[] args) {
         Solution solution = new CombinationSum().new Solution();
         // TO TEST
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        helper(res, new ArrayList<>(), candidates, target, 0);
        return res;
    }

    public void helper(List<List<Integer>> res, List<Integer> list, int[] arr, int target, int start){
        if(target == 0){
            res.add(new ArrayList<>(list));
            return;
        }

        for(int i = start; i < arr.length; i++){
            if(target < arr[i]){
                continue;
            }
            list.add(arr[i]);
            helper(res, list, arr, target - arr[i], i);
            //删除上一个节点
            list.remove(list.size() - 1);
        }
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
```

#### 全排列

```java
//给定一个 没有重复 数字的序列，返回其所有可能的全排列。 
//
// 示例: 
//
// 输入: [1,2,3]
//输出:
//[
//  [1,2,3],
//  [1,3,2],
//  [2,1,3],
//  [2,3,1],
//  [3,1,2],
//  [3,2,1]
//] 
// Related Topics 回溯算法 
// 👍 831 👎 0
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length == 0) return res;
        List<Integer> list = new ArrayList<>();
        solve(nums, list, res);
        return res;
    }
    public void solve(int[] nums, List<Integer> list, List<List<Integer>> res){
        if(nums.length == list.size()){
            res.add(new ArrayList<>(list));
        }
        for(int num : nums){
            if(!list.contains(num)){
                list.add(num);
                solve(nums, list, res);
                list.remove(list.size() - 1);
            }
        }
    }
}


//如果是有重复的版本
public class solution {
    List<List<Integer>> lists = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        if (nums == null || nums.length == 0) return lists;
        List<Integer> list = new ArrayList<>();
        backtrack(nums, 0, list);
        return lists;
    }

    void backtrack(int[] nums, int start, List<Integer> list){
        if (list.size() == nums.length){
            lists.add(new ArrayList<>(list));
            return;
        }

        HashSet<Integer> set = new HashSet<>();
        for (int i = start; i < nums.length; i++){
            
            // 与无重复数字全排列的唯一不同之处
            if (set.contains(nums[i])){
                continue;
            }
            set.add(nums[i]);

            swap(nums, i, start);
            list.add(nums[start]);
            backtrack(nums, start + 1, list);
            list.remove(list.size() - 1);
            swap(nums, i, start);
        }
    }

    void swap(int[] digit, int left, int right){
        int tmp = digit[left];
        digit[left] = digit[right];
        digit[right] = tmp;
    }
}
```

#### 数组的子集（回溯法）

```java
//给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 
//
// 说明：解集不能包含重复的子集。 
//
// 示例: 
//
// 输入: nums = [1,2,3]
//输出:
//[
//  [3],
//  [1],
//  [2],
//  [1,2,3],
//  [1,3],
//  [2,3],
//  [1,2],
//  []
//] 
// Related Topics 位运算 数组 回溯算法 
// 👍 688 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0) return res;
        solve(nums, res, new ArrayList<>(), 0);
        return res;
    }

    public void solve(int[] nums, List<List<Integer>> res, List<Integer> list, int pos){
        res.add(new ArrayList<>(list));
        for (int i = pos; i < nums.length; i++) {
            list.add(nums[i]);
            solve(nums, res, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```

#### 矩阵中的路径

```java
/**
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。**/
//时间复杂度O(3^KMN):最差情况下，需要遍历矩阵中长度为K字符串的所有方案，时间复杂度为O(3^K);矩阵中共有MN个起点，时间复杂度为O(MN)
//空间复杂度O(K): 搜索过程中递归深度不超过K，因此系统因调用累积使用的栈空间为O(K),最坏情况下K = MN， 队规深度为MN

public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        int[][] flag = new int[rows][cols];
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                if(helper(matrix, rows, cols, i, j, 0, str, flag)){
                    return true;
                }
            }
        }
        
        return false;
    }
    
    public boolean helper(char[] matrix, int rows, int cols, int x, int y, int k, char[] str, int[][] flag){
        int index = x * cols + y;
        if(x >= rows || x < 0 || y >= cols || y < 0 || str[k] != matrix[index] || flag[x][y] == 1){
            return false;
        }
        
        flag[x][y] = 1;
        
        if(k == str.length - 1) return true;
        
        if(helper(matrix, rows, cols, x + 1, y, k + 1, str, flag) || helper(matrix, rows, cols, x - 1, y, k + 1, str, flag) ||
          helper(matrix, rows, cols, x, y + 1, k + 1, str, flag) || helper(matrix, rows, cols, x, y - 1, k + 1, str, flag)){
            return true;
        }
        
        flag[x][y] = 0;
        return false;
        
    }
}
```



### dp

#### 0/1背包问题

```java
class Solution{
  public int ZeroInePack(int V, int N, int[] weight, int[] value){
    int[][] dp = new int[N + 1][V + 1];
    //为了便于理解,将dp[i][0]和dp[0][j]均置为0，从1开始计算
        for(int i=1;i<N+1;i++){
            for(int j=1;j<V+1;j++){
                //如果第i件物品的重量大于背包容量j,则不装入背包
                //由于weight和value数组下标都是从0开始,故注意第i个物品的重量为weight[i-1],价值为value[i-1]
                if(weight[i-1] > j)
                    dp[i][j] = dp[i-1][j];
                else
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value[i-1]);
            }
        }
    		//以下是输出商品编号
        //则容量为V的背包能够装入物品的最大值为
        int maxValue = dp[N][V];
        //逆推找出装入背包的所有商品的编号
        int j=V;
        String numStr="";
        for(int i=N;i>0;i--){
            //若果dp[i][j]>dp[i-1][j],这说明第i件物品是放入背包的
            if(dp[i][j]>dp[i-1][j]){
                numStr = i+" "+numStr;
                j=j-weight[i-1];
            }
            if(j==0)
                break;
        }
        return numStr;  
  }
}

//优化空间
public static int ZeroOnePack2(int V,int N,int[] weight,int[] value){
        //动态规划
        int[] dp = new int[V+1];
        for(int i=1;i<N+1;i++){
            //逆序实现
            for(int j=V;j>=weight[i-1];j--){
                dp[j] = Math.max(dp[j-weight[i-1]] + value[i-1],dp[j]);
            }
        }
        return dp[V];       
    }
```

#### 礼物的最大价值

```java
/**在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 

示例 1:

输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
**/

class Solution {
    public int maxValue(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < rows; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
        for(int j = 1; j < cols; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
        for(int i = 1; i < rows; i++){
            for(int j = 1; j < cols; j++){
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[rows - 1][cols - 1];
    }
}
```



#### 零钱兑换（完全背包问题）

```java
//给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回
// -1。 
//
// 
//
// 示例 1: 
//
// 输入: coins = [1, 2, 5], amount = 11
//输出: 3 
//解释: 11 = 5 + 5 + 1 
//
// 示例 2: 
//
// 输入: coins = [2], amount = 3
//输出: -1 
//
// 
//
// 说明: 
//你可以认为每种硬币的数量是无限的。 
// Related Topics 动态规划 
// 👍 737 👎 0
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            dp[i] = Integer.MAX_VALUE;
            for(int j = 0; j < coins.length; j++){
                if(coins[j] <= i && dp[i - coins[j]] != Integer.MAX_VALUE){
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
            if(dp[i] == Integer.MAX_VALUE){
                dp[i] = -1;
            }
        }
        return dp[amount];
    }
}

//零钱兑换2  求最少方案数量
class Solution {
  public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int x = coin; x < amount + 1; ++x) {
        dp[x] += dp[x - coin];
      }
    }
    return dp[amount];
  }
}
```

#### 最长上升子序列

```java
//给定一个无序的整数数组，找到其中最长上升子序列的长度。 
//
// 示例: 
//
// 输入: [10,9,2,5,3,7,101,18]
//输出: 4 
//解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 
//
// 说明: 
//
// 
// 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 
// 你算法的时间复杂度应该为 O(n2) 。 
// 
//
// 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 
// Related Topics 二分查找 动态规划 
// 👍 884 👎 0

class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 1;
        dp[0] = 1;
        for(int i = 1; i < nums.length; i++){
            dp[i] = 1;
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

#### 乘积最大子数组

```java
//给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 
//
// 
//
// 示例 1: 
//
// 输入: [2,3,-2,4]
//输出: 6
//解释: 子数组 [2,3] 有最大乘积 6。
// 
//
// 示例 2: 
//
// 输入: [-2,0,-1]
//输出: 0
//解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 
// Related Topics 数组 动态规划 
// 👍 686 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length == 0 || nums == null) return 0;
        int[] maxdp = new int[nums.length];
        int[] mindp = new int[nums.length];
        maxdp[0] = nums[0];
        mindp[0] = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.length; i++){
            maxdp[i] = Math.max(maxdp[i - 1] * nums[i], Math.max(mindp[i - 1] * nums[i], nums[i]));
            mindp[i] = Math.min(mindp[i - 1] * nums[i], Math.min(maxdp[i - 1] * nums[i], nums[i]));
            res = Math.max(res, maxdp[i]);
        }
        return res;
    }
}
```

#### 打家劫舍

```java
//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上
//被小偷闯入，系统会自动报警。 
//
// 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 
//
// 示例 1： 
//
// 输入：[1,2,3,1]
//输出：4
//解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
//     偷窃到的最高金额 = 1 + 3 = 4 。 
//
// 示例 2： 
//
// 输入：[2,7,9,3,1]
//输出：12
//解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
//     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
// 
// 提示： 
//
// 
// 0 <= nums.length <= 100 
// 0 <= nums[i] <= 400 
// 
// Related Topics 动态规划 
// 👍 1000 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = nums[0] > nums[1] ? nums[0] : nums[1];
        for(int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.length - 1];
    }
}
```

#### 剪绳子

```java
/**
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
**/
//动态规划 空间复杂度O(n) 时间复杂度O(n^2)
class Solution {
    public int cuttingRope(int n) {
        if(n < 4) return n - 1;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for(int i = 4; i <= n; i++){
            for(int j = 1; j <= i / 2; j++){
                dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);
            }
        }
        return dp[n];
    }
}

//贪心法  时间复杂度O(1) 空间复杂度O(1)
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```

#### 最大字段和(分治法)

```java
//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 
//
// 示例: 
//
// 输入: [-2,1,-3,4,-1,2,1,-5,4]
//输出: 6
//解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
// 
//
// 进阶: 
//
// 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 
// Related Topics 数组 分治算法 动态规划 
// 👍 2259 👎 0

//分治法时间复杂度O(NlogN),空间复杂度O(logN)
class Solution {
    public int maxSubArray(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        return helper(nums, lo, hi);
    }
    public int helper(int[] nums, int l, int r){
        if(l == r) return nums[l];
        int mid = (l + r) >> 1;
        int leftSum = helper(nums, l, mid);
        int rightSum = helper(nums, mid + 1, r);
        int sum1 = Integer.MIN_VALUE;
        int sum2 = Integer.MIN_VALUE;
        int left = 0;
        int right = 0;
        for(int i = mid; i >= 0; i--){
            left += nums[i];
            sum1 = Math.max(sum1, left);
        }
        for(int i = mid + 1; i <= r; i++){
            right += nums[i];
            sum2 = Math.max(sum2, right);
        }
        return Math.max(Math.max(leftSum, rightSum), sum1 + sum2);
    }
}

//dp法
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if(array.length == 0 || array == null) return 0;
        int[] dp = new int[array.length];
        dp[0] = array[0];
        int res = array[0];
        for(int i = 1; i < array.length; i++){
            dp[i] = Math.max(array[i], dp[i - 1] + array[i]);
            res = Math.max(res, dp[i]);
        }
        
        return res;
    }
    
}
```

#### 三角形最小路径和

```java
/**
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

 

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
**/
//时间空间复杂度 O(n^2)
//动态规划
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle.size() == 0) return 0;
        int[][] dp = new int[triangle.size() + 1][triangle.size() + 1];

        for(int i = triangle.size() - 1; i >= 0; i--){
            List<Integer> list = triangle.get(i);
            for(int j = 0; j < list.size(); j++){
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + list.get(j);
            }
        }
        return dp[0][0];
    }
}
//递归
class Solution {
    Integer[][] memo;
    public int minimumTotal(List<List<Integer>> triangle) {
        memo = new Integer[triangle.size()][triangle.size()];
        return  dfs(triangle, 0, 0);
    }

    private int dfs(List<List<Integer>> triangle, int i, int j) {
        if (i == triangle.size()) {
            return 0;
        }
        if (memo[i][j] != null) {
            return memo[i][j];
        }
        return memo[i][j] = Math.min(dfs(triangle, i + 1, j), dfs(triangle, i + 1, j + 1)) + triangle.get(i).get(j);
    }
}

```

### 二分查找

#### 在排序数组中查找数字

```java
/**统计一个数字在排序数组中出现的次数。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
**/
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0) return 0;
        int rightBound = rightSearch(nums, target);
        int leftBound = leftSearch(nums, target);
        if(rightBound == -1 && leftBound == -1) return 0;
        return  rightBound - leftBound + 1;
    }

    public int leftSearch(int[] nums, int target){
        int lo = 0;
        int hi = nums.length - 1;
        while(lo + 1 < hi){
            int mid = (lo + hi) >> 1;
            if(nums[mid] < target){
                lo = mid;
            }else if(nums[mid] > target){
                hi = mid;
            }else{
                hi = mid;
            }
        }
        if(nums[lo] == target) return lo;
        if(nums[hi] == target) return hi;
        return -1;
    }

    public int rightSearch(int[] nums, int target){
        int lo = 0;
        int hi = nums.length - 1;
        while(lo + 1 < hi){
            int mid = (lo + hi) >> 1;
            if(nums[mid] < target){
                lo = mid;
            }else if(nums[mid] > target){
                hi = mid;
            }else{
                lo = mid;
            }
        }
        if(nums[hi] == target) return hi;
        if(nums[lo] == target) return lo;
        return -1;
    }
}
```

#### 搜索旋转排序数组

```java
//假设按照升序排序的数组在预先未知的某个点上进行了旋转。 
//
// ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 
//
// 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 
//
// 你可以假设数组中不存在重复的元素。 
//
// 你的算法时间复杂度必须是 O(log n) 级别。 
//
// 示例 1: 
//
// 输入: nums = [4,5,6,7,0,1,2], target = 0
//输出: 4
// 
//
// 示例 2: 
//
// 输入: nums = [4,5,6,7,0,1,2], target = 3
//输出: -1 
// Related Topics 数组 二分查找 
// 👍 866 👎 0
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0 || nums == null) return -1;
        int lo = 0;
        int hi = nums.length - 1;
        while(lo <= hi){
            int mid = (lo + hi) >> 1;
            if(nums[mid] == target){
                return mid;
            }
            //左半部分有序
            if(nums[0] <= nums[mid]){
                if(nums[0] <= target && nums[mid] > target){
                    hi = mid - 1;
                }else{
                    lo = mid + 1;
                }
            }else{
                if(nums[mid] < target && target <= nums[nums.length - 1]){
                    lo = mid + 1;
                }else{
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
}

```

#### 旋转数组最小数字

```java
//时间复杂度 logn
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0 || array == null) return 0;
        int lo = 0;
        int hi = array.length - 1;
        while(lo < hi){
            if(array[lo] < array[hi]) return array[lo];
            int mid = (lo + hi) >> 1;
            if(array[lo] < array[mid]) lo = mid + 1;
            else if(array[lo] > array[mid]) hi = mid;
            else lo++;
        }
       
        return array[lo];
    }
}
```



### 位运算

#### 快速幂（整数的幂次方）

```java
//实现 pow(x, n) ，即计算 x 的 n 次幂函数。 
//
// 示例 1: 
//
// 输入: 2.00000, 10
//输出: 1024.00000
// 
//
// 示例 2: 
//
// 输入: 2.10000, 3
//输出: 9.26100
// 
//
// 示例 3: 
//
// 输入: 2.00000, -2
//输出: 0.25000
//解释: 2-2 = 1/22 = 1/4 = 0.25 
//
// 说明: 
//
// 
// -100.0 < x < 100.0 
// n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 
// 
// Related Topics 数学 二分查找 
// 👍 468 👎 0

    //leetcode submit region begin(Prohibit modification and deletion)
//快速幂 时间复杂度 O(logn) 空间复杂度O(1)
    class Solution {
        public double myPow(double x, int n) {
            if(x == 0.0f) return 0.0d;
            long b = n;
            double res = 1.0;
            if(b < 0) {
                x = 1 / x;
                b = -b;
            }
            while(b > 0) {
                if((b & 1) == 1) res *= x;
                x *= x;
                b >>= 1;
            }
            return res;
        }
    }
}

//常规解法
public class Solution {
    public double Power(double base, int exponent) {
        
        if(base == 0.0) return 0.0;
        int e = exponent > 0 ? exponent : -exponent;
        
        double res = 1.0;
        
        for(int i = 0; i < e; i++){
            res *= base;
        }
        
        return exponent > 0 ? res : 1 / res;
  }
}
```

#### 两个数字相加（加法器）

```java
//不使用运算符 + 和 - ，计算两整数 a 、b 之和。 
//
// 示例 1: 
//
// 输入: a = 1, b = 2
//输出: 3
// 
//
// 示例 2: 
//
// 输入: a = -2, b = 3
//输出: 1 
// Related Topics 位运算 
// 👍 290 👎 0
class Solution {
    public int getSum(int a, int b) {
        if(a == 0) return b;
        if(b == 0) return a;
        int low;
        int carry;
        while(true){
            low = a ^ b;
            carry = a & b;
            if(carry == 0) break;
            a = low;
            b = carry << 1;
        }
        return low;
    }
}
```

#### 求1+2+3+……+n

```java
/**
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
**/
class Solution {
    public int sumNums(int n) {
        boolean flag = n > 0 && (n += sumNums(n - 1)) > 0;
        return n;
    }
}

```

#### 数组中数字出现的次数

```java
/**
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。


示例 1：

输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
**/
class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0;
        int[] res = new int[2];
        for(int num : nums){
            sum ^= num;
        }
        int lowbit = 1;
        while((lowbit & sum) == 0){
            lowbit <<= 1;
        }
        for(int num : nums){
            if((num & lowbit) == 0){
                res[0] ^= num;
            }else{
                res[1] ^= num;
            }
        }
        return res;
    }
```

### 丑数

```java
/**
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。


示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
**/
class Solution {
    public int nthUglyNumber(int n) {
        int p2 = 0;
        int p3 = 0;
        int p5 = 0;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for(int i = 1; i <= n; i++){
            dp[i] = Math.min(Math.min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);
            if(dp[i] == dp[p2] * 2) p2++;
            if(dp[i] == dp[p3] * 3) p3++;
            if(dp[i] == dp[p5] * 5) p5++;
        }
        return dp[n - 1];
    }
}
```

### 数据流中的中位数

```java
//查找时间复杂度 O(1) 添加时间复杂度 O(logN)
//空间复杂度 O(N)
class MedianFinder {
    Queue<Integer> min;
    Queue<Integer> max;
    /** initialize your data structure here. */
    public MedianFinder() {
        min = new PriorityQueue<>();
        max = new PriorityQueue<>((o1, o2) -> (o2.compareTo(o1)));
    }
    
    public void addNum(int num) {
        max.add(num);
        min.add(max.poll());
        if(max.size() < min.size()){
            max.add(min.poll());
        }
    }
    
    public double findMedian() {
        if(max.size() > min.size()) return max.peek();
        return (max.peek() + min.peek()) / 2.0;
    }
}
```

### 和为S的连续整数序列

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 1;
        int sum = 0;
        List<int[]> res = new ArrayList<>();
        while(l <= target / 2){
            if(sum < target){
                sum += r;
                r++;
            }else if(sum > target){
                sum -= l;
                l++;
            }else{
                int[] arr = new int[r - l];
                int index = 0;
                for(int i = l; i < r; i++){
                    arr[index++] = i;
                }
                res.add(arr);
                sum -= l;
                l++;
            }
        }
        return res.toArray(new int[res.size()][]);
    }
}
```

### 除自身以外数组的乘积

```java
//给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之
//外其余各元素的乘积。 
//
// 
//
// 示例: 
//
// 输入: [1,2,3,4]
//输出: [24,12,8,6] 
//
// 
//
// 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 
//
// 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 
//
// 进阶： 
//你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 
// Related Topics 数组 
// 👍 543 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
public class ProductOfArrayExceptSelf {
    public static void main(String[] args) {
        Solution solution = new ProductOfArrayExceptSelf().new Solution();
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        if(nums == null || nums.length == 0) return new int[]{};
        int p = 1;
        int q = 1;
        int[] res = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            res[i] = p;
            p *= nums[i];
        }
        for(int i = nums.length - 1; i > 0; i--){
            q *= nums[i];
            res[i - 1] *= q;
        }

        return res;
    }
}
```

### 逆序对

``` java
class Solution {
    int sum;
    public int reversePairs(int[] array) {
        if(array.length == 0 || array == null) return 0;
        sum = 0;
        int l = 0;
        int r = array.length - 1;
        mergeSort(array, l, r);
        return sum;
    }
    public void mergeSort(int[] arr, int lo, int hi){
        if(arr == null || arr.length == 0) return;
        int mid = (lo + hi) >> 1;
        if(lo < hi){
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid + 1, hi);
            merge(arr, lo, hi, mid);
        }
    }
    public void merge(int[] arr, int l, int r, int mid){
        int i = l;
        int j = mid + 1;
        int index = 0;
        int[] tmp = new int[r - l + 1];
        while(i <= mid && j <= r){
            if(arr[i] > arr[j]){
                tmp[index++] = arr[j++];
                sum += mid - i + 1;
            }else{
                tmp[index++] = arr[i++];
            }
        }
        while(i <= mid){
            tmp[index++] = arr[i++];
        }
        while(j <= r){
            tmp[index++] = arr[j++];
        }
        index = 0;
        for(int k = l; k <= r; k++){
            arr[k] = tmp[index++];
        }
    }
}
```



### 寻找峰值

```java
//峰值元素是指其值大于左右相邻值的元素。 
//
// 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 
//
// 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 
//
// 你可以假设 nums[-1] = nums[n] = -∞。 
//
// 示例 1: 
//
// 输入: nums = [1,2,3,1]
//输出: 2
//解释: 3 是峰值元素，你的函数应该返回其索引 2。 
//
// 示例 2: 
//
// 输入: nums = [1,2,1,3,5,6,4]
//输出: 1 或 5 
//解释: 你的函数可以返回索引 1，其峰值元素为 2；
//     或者返回索引 5， 其峰值元素为 6。
// 
//
// 说明: 
//
// 你的解法应该是 O(logN) 时间复杂度的。 
// Related Topics 数组 二分查找 
// 👍 269 👎 0
class Solution {
    public int findPeakElement(int[] nums) {
        return search(nums, 0, nums.length - 1);
    }

    public int search(int[] nums, int l, int r){
        if(l == r) return l;
        int mid = (l + r) >> 1;
        if(nums[mid] > nums[mid + 1]){
             return search(nums, l, mid);
        }
        return search(nums, mid + 1, r);
    }
}
```

### 三数之和

```java
//给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复
//的三元组。 
//
// 注意：答案中不可以包含重复的三元组。 
//
// 
//
// 示例： 
//
// 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
//
//满足要求的三元组集合为：
//[
//  [-1, 0, 1],
//  [-1, -1, 2]
//]
// 
// Related Topics 数组 双指针 
// 👍 2453 👎 0
//时间复杂度 O(n^2)
package com.sheva.leetcode.editor.cn;
import java.util.*;
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums == null || nums.length == 0) return res;
        Arrays.sort(nums);
        for(int k = 0; k < nums.length - 2; k++){
            if(nums[k] > 0) break;
            if(k > 0 && nums[k] == nums[k - 1]) continue;
            int lo = k + 1;
            int hi = nums.length - 1;
            while(lo < hi){
                int sum = nums[k] + nums[lo] + nums[hi];
                if(sum < 0){
                    while(lo < hi && nums[lo] == nums[++lo]);
                }else if (sum > 0){
                    while(lo < hi && nums[hi] == nums[--hi]);
                }else{
                    res.add(Arrays.asList(nums[k], nums[lo], nums[hi]));
                    while(lo < hi && nums[lo] == nums[++lo]);
                    while(lo < hi && nums[hi] == nums[--hi]);
                }
            }
        }
        return res;
    }
}

//最接近的三数之和
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int min = Integer.MAX_VALUE;
        int res = 0;
        for(int k = 0; k < nums.length; k++){
            if(k >0 && nums[k] == nums[k - 1]) continue;
            int lo = k + 1;
            int hi = nums.length - 1;
            while(lo < hi){
                int sum = nums[k] + nums[lo] + nums[hi];
                if(Math.abs(sum - target) < min){
                    min = Math.abs(sum - target);
                    res = sum;
                }
                if(sum > target){
                    while(lo < hi && nums[hi] == nums[--hi]);
                }else if(sum < target){
                    while(lo < hi && nums[lo] == nums[++lo]);
                }else{
                    return target;
                }
            }
        }
        return res;
    }
}
```

### 最长连续序列

```java
/**
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
**/
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0 || nums == null) return 0;
        Set<Integer> set = new HashSet<>();
        for(int num : nums){
            set.add(num);
        }
        int res = 1;
        for(int i = 0; i < nums.length; i++){
            if(!set.contains(nums[i] - 1)){
                int curr = nums[i];
                int cnt = 1;
                while(set.contains(curr + 1)){
                    cnt++;
                    curr++;
                }
                res = Math.max(cnt, res);
            }
        }

        return res;
    }
}
```

### 把数组排成最小的数

```java
/**
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 

示例 1:

输入: [10,2]
输出: "102"
示例 2:

输入: [3,30,34,5,9]
输出: "3033459"
**/
//自定义快排 时间复杂度 O(nlogn) 最差为O(n^2) 空间复杂度O(n)
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        fastSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
    void fastSort(String[] strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i < j) {
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) >= 0 && i < j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) <= 0 && i < j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        }
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    }
}

//内置函数
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++) 
            strs[i] = String.valueOf(nums[i]);
        Arrays.sort(strs, (x, y) -> (x + y).compareTo(y + x));
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
}
```





### 跳跃游戏

```java
//给定一个非负整数数组，你最初位于数组的第一个位置。 
//
// 数组中的每个元素代表你在该位置可以跳跃的最大长度。 
//
// 判断你是否能够到达最后一个位置。 
//
// 示例 1: 
//
// 输入: [2,3,1,1,4]
//输出: true
//解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
// 
//
// 示例 2: 
//
// 输入: [3,2,1,0,4]
//输出: false
//解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
// 
// Related Topics 贪心算法 数组 
// 👍 766 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        int rightBound = 0;
        for (int i = 0; i < len; i++) {
            if (i <= rightBound){
                rightBound = Math.max(rightBound, i + nums[i]);
            }
            if(rightBound >= len - 1){
                return true;
            }
        }
        return false;
    }
}
```

### 数组加一

```java
//给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 
//
// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 
//
// 你可以假设除了整数 0 之外，这个整数不会以零开头。 
//
// 示例 1: 
//
// 输入: [1,2,3]
//输出: [1,2,4]
//解释: 输入数组表示数字 123。
// 
//
// 示例 2: 
//
// 输入: [4,3,2,1]
//输出: [4,3,2,2]
//解释: 输入数组表示数字 4321。
// 
// Related Topics 数组 
// 👍 522 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i = digits.length - 1; i >= 0; i--){
            digits[i]++;
            digits[i] %= 10;
            if(digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
}
```

### 合并两个有序数组

```java
//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 
//
// 
//
// 说明: 
//
// 
// 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 
// 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 
// 
// 示例: 
//
// 输入:
//nums1 = [1,2,3,0,0,0], m = 3
//nums2 = [2,5,6],       n = 3
//
//输出: [1,2,2,3,5,6] 
// Related Topics 数组 双指针 
// 👍 578 👎 0
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while(i >= 0 && j >= 0){
            if(nums1[i] > nums2[j]){
                nums1[k--] = nums1[i--];
            }else{
                nums1[k--] = nums2[j--];
            }
        }
        while(j >= 0) nums1[k--] = nums2[j--];
    }
}
```

### 数组中第k大元素（前K大元素）

```java
//在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 
//
// 示例 1: 
//
// 输入: [3,2,1,5,6,4] 和 k = 2
//输出: 5
// 
//
// 示例 2: 
//
// 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
//输出: 4 
//
// 说明: 
//
// 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 
// Related Topics 堆 分治算法 
// 👍 638 👎 0
// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
// 1. 若目前堆的大小小于K，将当前数字放入堆中。
// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
//自带最大堆 时间复杂度O(nlogn)
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);
        for (int num: arr) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (num < pq.peek()) {
                pq.poll();
                pq.offer(num);
            }
        }
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) {
            res[idx++] = num;
        }
        return res;
    }
}

//快排思想
//时间复杂度 O(n) 最坏O(n^2)每次都分到最大最小值
//空间复杂度 O(logn) 最坏O(n)
class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(nums.length == 0 || nums == null) return -1;
        int lo = 0;
        int hi = nums.length - 1;
        while(lo < hi){
            int index = partition(nums, lo, hi);
            if(index > k - 1) hi = index - 1;
            else if(index < k - 1) lo = index + 1;
            else break;
        }
        return nums[k - 1];
    }
    public int partition(int[] arr, int lo, int hi){
        int pivot = arr[lo];
        int index = lo;
        for(int i = lo; i <= hi; i++){
            if(arr[i] > pivot) swap(arr, i, ++index);
        }

        swap(arr, lo, index);
        return index;
    }
    public void swap(int[] arr, int lo, int hi){
        int tmp = arr[lo];
        arr[lo] = arr[hi];
        arr[hi] = tmp;
    }
}
```



### 滑动窗口的最大值

```java
//给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 
//
//
// 返回滑动窗口中的最大值。 
//
// 
//
// 进阶： 
//
// 你能在线性时间复杂度内解决此题吗？ 
//
// 
//
// 示例: 
//
// 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
//输出: [3,3,5,5,6,7] 
//解释: 
//
//  滑动窗口的位置                最大值
//---------------               -----
//[1  3  -1] -3  5  3  6  7       3
// 1 [3  -1  -3] 5  3  6  7       3
// 1  3 [-1  -3  5] 3  6  7       5
// 1  3  -1 [-3  5  3] 6  7       5
// 1  3  -1  -3 [5  3  6] 7       6
// 1  3  -1  -3  5 [3  6  7]      7 
//
// 
//
// 提示： 
//
// 
// 1 <= nums.length <= 10^5 
// -10^4 <= nums[i] <= 10^4 
// 1 <= k <= nums.length 
// 
// Related Topics 堆 Sliding Window 
// 👍 481 👎 0
//时间复杂度 O(n)  空间复杂度 O(k)
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length == 0) return new int[]{};
        Deque<Integer> dq = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        for(int i = 0; i < nums.length; i++){
            if(!dq.isEmpty() && dq.getFirst() < i - k + 1){
                dq.removeFirst();
            }
            while(!dq.isEmpty() && nums[dq.getLast()] < nums[i]){
                dq.removeLast();
            }
            dq.add(i);
            if(i >= k - 1){
                res[i - k + 1] = nums[dq.getFirst()];
            }
        }
        return res;
    }
}

```





### 移动零

```java
//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 
//
// 示例: 
//
// 输入: [0,1,0,3,12]
//输出: [1,3,12,0,0] 
//
// 说明: 
//
// 
// 必须在原数组上操作，不能拷贝额外的数组。 
// 尽量减少操作次数。 
// 
// Related Topics 数组 双指针 
// 👍 691 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
//    public void moveZeroes(int[] nums) {
//        if(nums == null || nums.length == 0) return;
//        int index = 0;
//        for(int i = 0; i < nums.length; i++){
//            if(nums[i] != 0) nums[index++] = nums[i];
//        }
//
//        for(int i = index; i < nums.length; i++){
//            nums[i] = 0;
//        }
//    }

        public void moveZeroes(int[] nums) {
            if(nums == null || nums.length == 0) return;
            int index = 0;
            for(int i = 0; i < nums.length; i++){
                if(nums[i] != 0) {
                    int tmp = nums[i];
                    nums[i] = nums[index];
                    nums[index++] = tmp;
                }
            }
        }
}
```

### 杨辉三角形

```java
//给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 
//
// 
//
// 在杨辉三角中，每个数是它左上方和右上方的数的和。 
//
// 示例: 
//
// 输入: 5
//输出:
//[
//     [1],
//    [1,1],
//   [1,2,1],
//  [1,3,3,1],
// [1,4,6,4,1]
//] 
// Related Topics 数组 
// 👍 336 👎 0

package com.sheva.leetcode.editor.cn;
import com.sun.tools.corba.se.idl.InterfaceGen;
import java.util.*;
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        if(numRows == 0) return res;
        List<Integer> firstLayer = new ArrayList<>();
        firstLayer.add(1);
        res.add(firstLayer);
        for(int i = 1; i < numRows; i++){
            List<Integer> list = new ArrayList<>();
            List<Integer> lastList = res.get(i - 1);
            list.add(1);
            if(i > 1){
                for(int j = 1; j < i; j++){
                    list.add(lastList.get(j - 1) + lastList.get(j));
                }
            }
            list.add(1);
            res.add(list);
        }
        return res;
    }
}
```



### 调整数组顺序使奇数在偶数前面

```java
//不稳定
class Solution {
    public int[] exchange(int[] nums) {
        int i = 0, j = nums.length - 1, tmp;
        while(i < j) {
            while(i < j && (nums[i] & 1) == 1) i++;
            while(i < j && (nums[j] & 1) == 0) j--;
            tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
        return nums;
    }
}
//稳定
public class Solution {
    public void reOrderArray(int [] array) {
        if(array == null || array.length == 0) return;
        int count = 0;
        for(int i = 0; i < array.length; i++){
            int tmp = array[i];
            if(array[i] % 2 == 1){//奇数
                for(int j = i - 1; j >= count; j--){
                    array[j + 1] = array[j];
                }
                array[count] = tmp;
                count++;
            }
        }
    }
}
```

### 有序矩阵第k小的数

```java
//给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。 
//请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 
//
// 
//
// 示例： 
//
// matrix = [
//   [ 1,  5,  9],
//   [10, 11, 13],
//   [12, 13, 15]
//],
//k = 8,
//
//返回 13。
// 
//
// 
//
// 提示： 
//你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。 
// Related Topics 堆 二分查找 
// 👍 398 👎 0
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int left = matrix[0][0];
        int right = matrix[n - 1][n - 1];
        while(left < right){
            int mid = (left + right) >> 1;
            if (check(matrix, mid, k, n)){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return left;
    }
    public boolean check(int[][] matrix, int mid, int k, int n){
        int i = n - 1;
        int j = 0;
        int num = 0;
        while(i >= 0 && j < n){
            if (matrix[i][j] <= mid){
                num += i + 1;
                j++;
            }else{
                i--;
            }
        }
        return num >= k;
    }
}
```

### 加油站

```java
/**
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
示例 1:

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
**/

解题思路

首先明确一点，如果加油站提供的油总和大于等于花费的油总和，那么必定可以绕环路行驶一周
我们尝试从编号0出发，不管油够不够，一直走到尾，期间记录gas[i]与cost[i]差值的总和sum，同时计算行驶过程中油箱中油量的最小值min（可以为负）。
如果总和sum<0，那么无论如何都不能够环绕一周，如果大于等于0，那么一定可以环绕一周
如果此时min>=0，那么行驶过程中油箱始终不为空，此时可以从0出发环绕一周
如果min<0，那么考虑更换起点，从右往左枚举起点，此时行驶方向还是从左往右，将min补充到大于0的点就是能够环绕一周的起始点，因为此时从新的起点出发，那么min>=0，这表示行驶过程中油箱始终不为空。

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0;
        int min = 0;
        for(int i = 0; i < gas.length; i++){
            // 统计加油量和耗油量
            sum += gas[i] - cost[i];
            min = Math.min(min, sum);
        }
        // 如果小于0，则不能环绕一周
        if(sum < 0)
            return -1;
        // 此时从起点出发能够环绕一周
        if(min >= 0)
            return 0;
        for(int i = gas.length-1; i >= 0; i--){
            int diff = gas[i] - cost[i];
            min += diff;
            // 如果该点能够将min补充到大于等于0，则该点为起点
            if(min >= 0)
                return i;
        }
        return -1;
    }
}

```

## 链表

### 删除重复节点

```java
/**
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
**/
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        if(pHead == null) return null;
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = pHead;
        ListNode curr = pHead;
        ListNode pre = dummyHead;
        while(curr != null){
            while(curr.next != null && curr.val == curr.next.val){
                curr = curr.next;
            }
            curr = curr.next;
            if(pre.next.next == curr){
                pre = pre.next;
            }else{
                pre.next = curr;
            }
            
        }
        return dummyHead.next;
    
    }
}
```



### 奇偶链表

```java
//给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 
//
// 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 
//
// 示例 1: 
//
// 输入: 1->2->3->4->5->NULL
//输出: 1->3->5->2->4->NULL
// 
//
// 示例 2: 
//
// 输入: 2->1->3->5->6->4->7->NULL 
//输出: 2->3->6->7->1->5->4->NULL 
//
// 说明: 
//
// 
// 应当保持奇数节点和偶数节点的相对顺序。 
// 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 
// 
// Related Topics 链表 
// 👍 222 👎 0

class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = head.next;
        while(even != null && even.next != null){
            odd.next = odd.next.next;
            even.next = even.next.next;
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;

    }
}
//leetcode submit region end(Prohibit modification and deletion)
class ListNode{
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int va){
        this.val = val;
    }
    ListNode(int val, ListNode next){
        this.val = val;
        this.next = next;
    }
}
```

### 排序链表

```java
//在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 
//
// 示例 1: 
//
// 输入: 4->2->1->3
//输出: 1->2->3->4
// 
//
// 示例 2: 
//
// 输入: -1->5->3->4->0
//输出: -1->0->3->4->5 
// Related Topics 排序 链表 
// 👍 671 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
    public ListNode sortList(ListNode head) {
        int len = 0;
        ListNode curr = head;
        while(curr != null){
            len++;
            curr = curr.next;
        }
        ListNode dummyHead = new ListNode(-1);
        dummyHead.next = head;
        //不同gap下分割链表
        for(int gap = 1; gap < len; gap *= 2){
            head = dummyHead;
            curr = head.next;
            while(curr != null){
              ListNode firstHead = curr;
              for(int i = 0; i < gap - 1 && curr != null; i++){
                  curr = curr.next;
              }
              if(curr == null) break;
              //定义第二个链表的头指针
              ListNode secondHead = curr.next;
              //断开链表
              curr.next = null;
              curr = secondHead;
              for(int i = 0; i < gap - 1 && curr != null; i++){
                  curr = curr.next;
              }
              ListNode thirdHead = null;
              if(curr != null){
                  thirdHead = curr.next;
                  curr.next = null;
              }
              curr = thirdHead;
              ListNode newHead = merge(firstHead, secondHead);
              head.next = newHead;
              while(head.next != null){
                  head = head.next;
              }
              head.next = thirdHead;
            }
        }
        return dummyHead.next;
    }

    public ListNode merge(ListNode l1, ListNode l2){
        ListNode dummyHead = new ListNode(-1);
        ListNode curr = dummyHead;
        while(l1 != null && l2 != null){
            if(l1.val < l2.val){
                curr.next = l1;
                l1 = l1.next;
            }else{
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        if(l1 != null) curr.next = l1;
        if(l2 != null) curr.next = l2;
        return dummyHead.next;
    }
}

```

### 合并k个升序链表

```java
//合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 
//
// 示例: 
//
// 输入:
//[
//  1->4->5,
//  1->3->4,
//  2->6
//]
//输出: 1->1->2->3->4->4->5->6 
// Related Topics 堆 链表 分治算法 
// 👍 829 👎 0

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null || lists.length == 0) return null;
        ListNode dummyHead = new ListNode(-1);
        ListNode curr = dummyHead;
        Queue<ListNode> q = new PriorityQueue<>((node1, node2) -> {
            return node1.val - node2.val;
        });
        for(ListNode list : lists){
            if(list != null){
                q.offer(list);
            }
        }
        while(!q.isEmpty()){
            ListNode node = q.poll();
            curr.next = node;
            curr = curr.next;
            if(node.next != null){
                q.offer(node.next);
            }
        }
        return dummyHead.next;
    }
}
```

### 链表相加

```java
//给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 
//
// 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 
//
// 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 
//
// 示例： 
//
// 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
//输出：7 -> 0 -> 8
//原因：342 + 465 = 807
// 
// Related Topics 链表 数学 
// 👍 4693 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
public class AddTwoNumbers {
    public static void main(String[] args) {
        Solution solution = new AddTwoNumbers().new Solution();
    }
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(-1);
        ListNode curr = dummyHead;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0){
            int a = l1 == null ? 0 : l1.val;
            int b = l2 == null ? 0 : l2.val;
            int sum = a + b;
            curr.next = new ListNode(sum % 10);
            carry = sum / 10;
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        return dummyHead.next;

    }
}
public class ListNode{
    int val;
    ListNode next;
    ListNode(int x){
        val = x;
    }
}
```

### 复制带随机指针的链表

```java
//给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 
//
// 要求返回这个链表的 深拷贝。 
//
// 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： 
//
// 
// val：一个表示 Node.val 的整数。 
// random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 
//
// 示例 1： 
//
// 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
//输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

import java.util.HashMap;
class Solution {
    public Node copyRandomList(Node head) {
//        HashMap<Node, Node> map = new HashMap<>();
//        Node curr = head;
//        while(curr != null){
//            map.put(curr, new Node(curr.val));
//            curr = curr.next;
//        }
//        curr = head;
//        while(curr != null){
//            map.get(curr).next = map.get(curr.next);
//            map.get(curr).random = map.get(curr.random);
//            curr = curr.next;
//        }
//        return map.get(head);
        if(head == null) return null;
        Node curr = head;
        while(curr != null){
            Node cloneNode = new Node(curr.val);
            Node nextNode = curr.next;
            curr.next = cloneNode;
            cloneNode.next = nextNode;
            curr = nextNode;
        }
        curr = head;
        while(curr != null){
            curr.next.random = curr.random == null ? null : curr.random.next;
            curr = curr.next.next;
        }
        curr = head;
        Node res = curr.next;
        while(curr != null){
            Node pClone = curr.next;
            curr.next = pClone.next == null ? null : pClone.next;
            pClone.next = pClone.next == null ? null : pClone.next.next;
            curr = curr.next;
        }
        return res;
    }
}
class Node{
    int val;
    Node next;
    Node random;
    public Node(int val){
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
```

## 二叉树

### 重建二叉树

```java
/**输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
**/
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder.length == 0 || inorder.length == 0) return null;
        TreeNode root = new TreeNode(preorder[0]);
        for(int i = 0; i < inorder.length; i++){
            if(inorder[i] == root.val){
                root.left = buildTree(Arrays.copyOfRange(preorder, 1, i + 1), Arrays.copyOfRange(inorder, 0, i));
                root.right = buildTree(Arrays.copyOfRange(preorder, i + 1, preorder.length), Arrays.copyOfRange(inorder, i + 1, inorder.length));
                break;
            }
        }
        return root;
    }
}
//堆栈做法 时间空间复杂度O(n)
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        int length = preorder.length;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < length; i++) {
            int preorderVal = preorder[i];
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    inorderIndex++;
                }
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }
        return root;
    }
}

```

### 二叉树的序列化与反序列化

```java
//序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方
//式重构得到原数据。 
//
// 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串
//反序列化为原始的树结构。 
//
// 示例: 
//
// 你可以将以下二叉树：
//
//    1
//   / \
//  2   3
//     / \
//    4   5
//
//序列化为 "[1,2,3,null,null,4,5]" 
//
// 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这
//个问题。 
//
// 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 
// Related Topics 树 设计 
// 👍 330 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        if(root == null) return "[]";
        sb.append("[");
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while (!q.isEmpty()){
            TreeNode tmp = q.poll();
            if(tmp != null){
                sb.append(tmp.val + ",");
                q.offer(tmp.left);
                q.offer(tmp.right);
            }else{
                sb.append(null + ",");
            }
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("") || data.equals("[]")) return null;
        String[] str = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(str[0]));
        Queue<TreeNode> parents = new LinkedList<>();
        TreeNode parent = root;
        boolean isLeft = true;
        for(int i = 1; i < str.length; i++){
            TreeNode curr = getNode(str[i]);
            if(isLeft){
                parent.left = curr;
            }else{
                parent.right = curr;
            }
            if(curr != null){
                parents.offer(curr);
            }
            if(!isLeft){
                parent = parents.poll();
            }
            isLeft = !isLeft;
        }
        return root;
    }

    public TreeNode getNode(String val){
        if(val.equals("null")) return null;
        return new TreeNode(Integer.parseInt(val));
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x){
        val = x;
    }
}
```

### 二叉树最大路径和

```java
//给定一个非空二叉树，返回其最大路径和。 
//
// 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 
//
// 示例 1: 
//
// 输入: [1,2,3]
//
//       1
//      / \
//     2   3
//
//输出: 6
// 
//
// 示例 2: 
//
// 输入: [-10,9,20,null,null,15,7]
//
//   -10
//   / \
//  9  20
//    /  \
//   15   7
//
//输出: 42 
// Related Topics 树 深度优先搜索 
// 👍 626 👎 0
class Solution {
    int result;
    public int maxPathSum(TreeNode root) {
        result = Integer.MIN_VALUE;
        getPath(root);
        return result;
    }
    public int getPath(TreeNode root){
        if(root == null){
            return 0;
        }
        int l = Math.max(getPath(root.left), 0);
        int r = Math.max(getPath(root.right), 0);
        result = Math.max(result, l + r + root.val);
        return Math.max(l, r) + root.val;
    }
}
```

### 路径总和

```java
//给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
//递归 时间复杂度 O(N) 空间副啊度 O(H)为树的高度 O(logN) 
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null) return false;
        if(root.left == null && root.right == null) return sum == root.val;

        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}

//广度优先搜索 记录从根节点到当前节点的路径和，防止重复计算。 使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径 时间空间复杂度 O(N)
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        Queue<TreeNode> queNode = new LinkedList<TreeNode>();
        Queue<Integer> queVal = new LinkedList<Integer>();
        queNode.offer(root);
        queVal.offer(root.val);
        while (!queNode.isEmpty()) {
            TreeNode now = queNode.poll();
            int temp = queVal.poll();
            if (now.left == null && now.right == null) {
                if (temp == sum) {
                    return true;
                }
                continue;
            }
            if (now.left != null) {
                queNode.offer(now.left);
                queVal.offer(now.left.val + temp);
            }
            if (now.right != null) {
                queNode.offer(now.right);
                queVal.offer(now.right.val + temp);
            }
        }
        return false;
    }
}

```

### 二叉树和为某一路径值的路径

```java
/**
输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
时间空间复杂度 O(N)
**/
public class Solution {
    public ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    public ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        if(root == null) return res;
        list.add(root.val);
        target -= root.val;
        if(target == 0 && root.left == null && root.right == null){
            res.add(new ArrayList<>(list));
        }
        
        FindPath(root.left, target);
        FindPath(root.right, target);
        
        list.remove(list.size() - 1);
        
        return res;
    }
}
```





### 验证是否是二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> s = new Stack<>();
        TreeNode node = root;
        TreeNode pre = null;
        while(node != null || !s.isEmpty()){
            if(node != null){
                s.push(node);
                node = node.left;
            }else{
                node = s.pop();
                if(pre != null && pre.val >= node.val){
                    return false;
                }
                pre = node;
                node = node.right;
            }
        }
        return true;
    }
}
```

### 平衡二叉树

```java
/**
输入一棵二叉树，判断是否是平衡二叉树
**/
//先序遍历+判断深度   时间复杂度 O(nlogn) 空间复杂度 O(n)
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null) return true;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        
        return Math.abs(leftDepth - rightDepth) <= 1 && IsBalanced_Solution(root.left) 
            && IsBalanced_Solution(root.right);
    }
    
    public int maxDepth(TreeNode root){
        if(root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        return l > r ? l + 1 : r + 1;
    }
}

//后序列遍历+剪枝  时间空间复杂度 O(n)
class Solution {
    public boolean isBalanced(TreeNode root) {
        return recur(root) != -1;
    }

    private int recur(TreeNode root) {
        if (root == null) return 0;
        int left = recur(root.left);
        if(left == -1) return -1;
        int right = recur(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
}

//非递归
public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null)
            return true;
        Stack<TreeNode> stack = new Stack();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode cur = stack.pop();
            int l = _Depth_Solution(cur.left);
            int r = _Depth_Solution(cur.right);        
            if(Math.abs(l-r) > 1)
                return false;
            if(cur.right != null)
                stack.push(cur.right);
            if(cur.left != null)
                stack.push(cur.left);            

        }
        return true;
    }
```

### 对称二叉树

```java
//给定一个二叉树，检查它是否是镜像对称的。 
//
// 
//
// 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 
//
//     1
//   / \
//  2   2
// / \ / \
//3  4 4  3
// 
//
// 
//
// 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 
//
//     1
//   / \
//  2   2
//   \   \
//   3    3
// 
// 进阶： 
//
// 你可以运用递归和迭代两种方法解决这个问题吗？ 
// Related Topics 树 深度优先搜索 广度优先搜索 
// 👍 951 👎 0
//时间复杂度 O(n) 空间复杂度O(n)
package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null) return true;
        return judge(root.left, root.right);
    }
    public boolean judge(TreeNode l, TreeNode r){
        if(l == null && r == null) return true;
        if(l == null || r == null) return false;
        return l.val == r.val && judge(l.left, r.right) && judge(l.right, r.left);
    }
}
public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x){
        val = x;
    }
}

/* 非递归 深度优先
* DFS使用stack来保存成对的节点
* 1.出栈的时候也是成对的 ，
        1.若都为空，继续；
        2.一个为空，返回false;
        3.不为空，比较当前值，值不等，返回false；
* 2.确定入栈顺序，每次入栈都是成对成对的，如left.left， right.right ;left.rigth,right.left
*/
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
        return isSymmetricalDFS(pRoot);
    }
    boolean isSymmetricalDFS(TreeNode pRoot){
        if(pRoot == null) return true;
        Stack<TreeNode> s = new Stack<>();
        s.push(pRoot.left);
        s.push(pRoot.right);
        while(!s.empty()) {
            TreeNode right = s.pop();//成对取出
            TreeNode left = s.pop();
            if(left == null && right == null) continue;
            if(left == null || right == null) return false;
            if(left.val != right.val) return false;
            //成对插入
            s.push(left.left);
            s.push(right.right);
            s.push(left.right);
            s.push(right.left);
        }
        return true;
    }
}
```

### 镜像二叉树

```java
/**
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1

 

示例 1：

输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
**/
//递归  时间空间复杂度O(n)
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    }
}

//辅助栈 时间空间复杂度O(n)
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        Stack<TreeNode> stack = new Stack<>() {{ add(root); }};
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        }
        return root;
    }

```

### 二叉树的最近公共祖先

```java
//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 
//
// 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（
//一个节点也可以是它自己的祖先）。” 
//
// 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 
//
//
// 示例 1: 
//
// 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
//输出: 3
//解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
// 
//
// 示例 2: 
//
// 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
//输出: 5
//解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
// 
// 说明: 
//
// 
// 所有节点的值都是唯一的。 
// p、q 为不同节点且均存在于给定的二叉树中。 
// 
// Related Topics 树 
// 👍 687 👎 0

package com.sheva.leetcode.editor.cn;
import java.util.*;
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode l = lowestCommonAncestor(root.left, p, q);
        TreeNode r = lowestCommonAncestor(root.right, p, q);
        if(l != null && r != null) return root;
        if(l == null && r != null) return r;
        if(l != null && r == null) return l;
        return null;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x){
        val = x;
    }
}
```

### 有序数组转为二叉搜索树

```java
/**
给定有序数组: [-10,-3,0,5,9],
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
**/
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length == 0) return null;
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int start, int end){
        if(start > end) return null;
        int mid = (start + end) >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, start, mid - 1);
        root.right = helper(nums, mid + 1, end);
        return root;
    }
}
```

### 二叉搜索树与双向链表

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    void dfs(Node cur) {
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) {
            pre.right = cur;
        }else{
            head = cur;
        }
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
}

//牛客网
public class Solution {
    TreeNode head = null;
    TreeNode realHead = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        solve(pRootOfTree);
        return realHead;
    }
    
    public void solve(TreeNode root){
        if(root == null) return;
        
        solve(root.left);
        if(head == null){
            head = root;
            realHead = root;
        }else{
            head.right = root;
            root.left = head;
            head = root;
        }
        solve(root.right);
    }
}
```



### 判断是否是二叉搜索树的后序遍历

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        if(postorder.length == 0 || postorder == null) return true;

        return helper(postorder, 0, postorder.length - 1);
    }

    public boolean helper(int[] seq, int start, int end){
        if(start >= end){
            return true;
        }
        int root = seq[end];
        int i;
        for(i = start; i < end; i++){
            if(seq[i] > root){
                break;
            }
        }

        for(int j = i; j < end; j++){
            if(seq[j] < root){
                return false;
            }
        }
        return helper(seq, start, i - 1) && helper(seq, i, end - 1);
    }
}
```

### 判断树的子结构

```java
/**
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

     3
    / \
   4   5
  / \
 1   2
给定的树 B：

   4 
  /
 1
**/
//时间复杂度O(mn) 空间复杂度O(m)
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B == null || A == null) return false;
        return judge(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    public boolean judge(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null) return false;

        return A.val == B.val && judge(A.left, B.left) && judge(A.right, B.right);
    }
}
```

### 序列化二叉树

```java
/**
请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
**/

public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "[]";
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> q = new LinkedList<>();
        sb.append("[");
        q.offer(root);
        while(!q.isEmpty()){
            TreeNode tmp = q.poll();
            if(tmp != null){
                sb.append(tmp.val + ",");
                q.offer(tmp.left);
                q.offer(tmp.right);
            }else{
                sb.append(null + ",");
            }
        }

        sb.deleteCharAt(sb.length() - 1);
        sb.append("]");
        return sb.toString();
    }


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("[]")) return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");

        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> q = new LinkedList<>();
        TreeNode parent = root;
        boolean isLeft = true;
        for(int i = 1; i < vals.length; i++){
            TreeNode cur = getNode(vals[i]);
            if(isLeft){
                parent.left = cur;
            }else{
                parent.right = cur;
            }
            if(cur != null){
                q.offer(cur);
            }
            if(!isLeft){
                parent = q.poll();
            }
            isLeft = !isLeft;
        }

        return root;
    }

    public TreeNode getNode(String val){
        if(val.equals("null")) return null;
        return new TreeNode(Integer.parseInt(val));
    }
}

```



## 堆栈

### 有效的括号

```java
//给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 
//
// 有效字符串需满足： 
//
// 
// 左括号必须用相同类型的右括号闭合。 
// 左括号必须以正确的顺序闭合。 
// 
//
// 注意空字符串可被认为是有效字符串。 
//
// 示例 1: 
//
// 输入: "()"
//输出: true
// 
//
// 示例 2: 
//
// 输入: "()[]{}"
//输出: true
// 
//
// 示例 3: 
//
// 输入: "(]"
//输出: false
// 
//
// 示例 4: 
//
// 输入: "([)]"
//输出: false
// 
//
// 示例 5: 
//
// 输入: "{[]}"
//输出: true 
// Related Topics 栈 字符串 
// 👍 1735 👎 0
class Solution {
    public boolean isValid(String s) {
        if(s == null || s.length() == 0) return true;
        HashMap<Character, Character> map = new HashMap<>();
        map.put(')', '(');
        map.put(']', '[');
        map.put('}', '{');
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if(map.containsKey(c)){
                if(stack.isEmpty()){
                    return false;
                }
                if(stack.pop() != map.get(c)){
                    return false;
                }
            }else{
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}
```

### 两个栈实现队列

```java
/**
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

 

示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
**/
class CQueue {
    Stack<Integer> stack1;
    Stack<Integer> stack2;

    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if(!stack2.isEmpty()){
            return stack2.pop();
        }else{
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
            return stack2.isEmpty() ? -1 : stack2.pop();
        }
    }
}
```

### 包含min函数的栈

```java
/**
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
**/
class MinStack {

    public Stack<Integer> stack;
    public int min;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int x) {
        if(x <= min){
            stack.push(min);
            min = x;
        }
        stack.push(x);
    }
    
    public void pop() {
        if(stack.isEmpty()) return;
        if(stack.pop() == min){
            min = stack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return min;
    }
}

//辅助栈
import java.util.*;
class MinStack {
    Stack<Integer> s1;
    Stack<Integer> s2;

    /** initialize your data structure here. */
    public MinStack() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void push(int x) {
        s1.push(x);
        if(s2.isEmpty() || x <= s2.peek()){
            s2.push(x);
        }
    }
    
    public void pop() {
        if(s1.isEmpty()) return;
        if((s1.pop()).equals( s2.peek() )){
            s2.pop();
        }
    }
    
    public int top() {
        if(s1.isEmpty()) return -1;
        return s1.peek();
    }
    
    public int min() {
        if(s2.isEmpty()) return -1;
        return s2.peek();
    }
}
```

### 队列的最大值

```java
/**
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]

**/
class MaxQueue {
    //主队列
    Queue<Integer> q;
    //辅助队列
    Deque<Integer> dq;
    public MaxQueue() {
        q = new LinkedList<>();
        dq = new LinkedList<>();
    }
    
    public int max_value() {
        if(dq.isEmpty()){
            return -1;
        }
        return dq.getFirst();
    }
    
    public void push_back(int value) {
        q.offer(value);
        //清除比自己更小的
        while(!dq.isEmpty() && dq.getLast() < value){
            dq.removeLast();
        }
        dq.add(value);
    }
    
    public int pop_front() {
        if(q.isEmpty()) return -1;
        int res = q.poll();
        if(res == dq.getFirst()){
            dq.removeFirst();
        }
        return res;
    }
}
```

### 栈的压入弹出序列

```java
/**
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
**/
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed.length == 0 && popped.length == 0) return true;
        if(pushed.length == 0 || popped.length == 0 || pushed.length != popped.length){
            return false;
        }
        Stack<Integer> stack = new Stack<>();
        int j = 0;
        for(int i = 0; i < pushed.length; i++){
            stack.push(pushed[i]);
            while(!stack.isEmpty() && stack.peek() == popped[j]){
                stack.pop();
                j++;
            }
        }

        return stack.isEmpty();
    }
}
```

## LRU

```java
import java.util.HashMap;
/**
 * @Author Sheva
 * @Date 2020/8/15
 */
public class LRUCache {
    private int count;
    private int capacity;
    private DLinkedNode head, tail;
    private HashMap<String, DLinkedNode> cache = new HashMap<>();
    //构造函数 初始化
    public LRUCache(int capacity){
        this.capacity = capacity;
        this.count = 0;
        //初始化头尾节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.pre = head;

    }
  
  public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        this.moveToHead(node);
        return node.val;
    }
    //暴露给外界的方法
    public void set(String key, int val){
        //查看是否存在内存
        DLinkedNode node = cache.get(key);
        if(node != null){
            node.val = val;
            this.moveToHead(node);
        }else{
            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.val = val;
            //加入缓存
            this.cache.put(key, newNode);
          	addNode(newNode);
            count++;
            if(count > capacity){
                DLinkedNode deleteNode = this.popTail();
                this.cache.remove(deleteNode.key);
                count--;
            }
        }
    }
    private void addNode(DLinkedNode node){
        node.pre = head;
        node.next = head.next;

        head.next.pre = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node){
        DLinkedNode pre = node.pre;
        DLinkedNode next = node.next;
        pre.next = next;
        next.pre = pre;
    }

    private void moveToHead(DLinkedNode node){
        this.removeNode(node);
        this.addNode(node);
    }
    private DLinkedNode popTail(){
        DLinkedNode node = tail.pre;
        this.removeNode(node);
        return node;
    }
}
class DLinkedNode{
    String key;
    int val;
    DLinkedNode pre;
    DLinkedNode next;
}
```

# 排序算法

## 堆排序

### 堆

1. 堆是一种数据结构，一般用一个**数组**表示，比如**int[]**。
2. 堆与数组的区别是： ***\*堆的下标表示是由三个组成，分别是 n，2n+1，2n+2\**** 其中
   **n**称为**父节点**，**2n+1**称为**左子节点**，**2n+2**称为**右子节点**。
3. 由于堆结构，把数据规划成一个图，类似**树形结构** ，跟完全二叉树类似，所以，一个堆结构中，也会有**根节点**，**非叶子节点，叶子节点**。**根节点指的是下标为0的数据，非叶子节点指的是既不是根节点，又含有子节点的数据。**

### 堆排序思想

堆排序是基于堆这种数据结构的排序，一般基于最大堆进行排序，默认堆的根节点是最大值，所以获取最大值 的时间复杂度是O(1)，而其他值是无序的，但是父节点一定大于子节点。堆排序的思想是，每次把最大值跟数组里最后一个值交换，然后把剩下的数据当做一个新的堆，然后重新调整新堆为最大堆，然后再把最大值和倒 数第二位交换位置，依次循环执行。由于调整堆的方法是一样的，只需循环调用用调整的方法，传入不同的数 组长度值即可。详细请看以下的代码过程。

### 实现代码

```java
public static void main(String[] args) {
        int[] arr=new int[]{1,3,2,9,10,7,8,1,63,18,21,1,0,-1,99,100};
        sort(arr,false);  //正序 ，正序构建最大顶堆
//        sort(arr,true);  //反序 ， 反序构建最小顶堆
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 堆排序 主要分两步：
     * 第一步：构建最大顶堆。
     * 调整的顺序：自下而上，自左向右调整
     * 方法：从最大的非叶子的节点，开始调整
     * code：最大的非叶子的节点下标是  floor((n-1)/2)
     *
     * 第二步：排序
     *
     * 交换最大值到数组最后
     * 调整剩余的数组成的堆。
     *
     */
    public static void sort(int[] arr,boolean reverse){
        for (int i = arr.length/2-1; i >=0; i--) {       // 构建最大/小顶堆
            adjustHeap(arr,i,arr.length-1,reverse);
        }
        for (int i = arr.length-1; i >=0; i--) {
            swap(arr,0,i);                    //交换根节点和数组最后一个数
            adjustHeap(arr,0,i-1,reverse);  //从根节点开始重新调整
        }
    }

    /**
     *  调整方法：
     * @param arr
     * @param current 当前节点
     * @param length
     */
    public static void adjustHeap(int[] arr,int current,int length,boolean reverse){
        int li = (current << 1) + 1; // 左子节点索引  index * 2 +1
        int ri = li + 1;            // 右子节点索引  左子节点+1
        int temp = li;              //  子节点最大值的索引
        if (li > length) return;  // 子节点索引超出计算范围，直接返回。
        if(reverse){
            if (ri<=length && arr[ri] < arr[li]) {// 先判断左右子节点，哪个较小。
                temp = ri;                          //保存最小值的下标
            }
            if (arr[temp] < arr[current]) {         //比较当前节点和子节点的最小值
                swap(arr,temp,current);             // 交换位置
                adjustHeap(arr,temp,length,true); // 如果原有最小值还有子节点，向下递归，从下往上调整
            }
        }else {
            if (ri<=length && arr[ri] > arr[li]) {// 先判断左右子节点，哪个较大。
                temp = ri;  //保存最大值的下标
            }
            if (arr[temp] > arr[current]) { //比较当前节点和子节点的最大值，哪个大，交换位置
                swap(arr,temp,current);     // 交换位置
                adjustHeap(arr,temp,length,false); // 如果原有最大值还有子节点，向下递归，从下往上调整
            }
        }

    }
    /**
     *  交换位置
     * @param arr
     * @param max
     * @param current
     */
    public static void  swap(int[] arr,int max,int current){
        int temp=arr[max];
        arr[max]=arr[current];
        arr[current]=temp;
    }
```

## 归并排序

```java
/**
     * 归并排序 采用分治思想 是一种稳定的排序算法。 将已有序的子序列合并，得到完全有序的序列
     * 时间复杂度 O(nlogn)
     * 空间复杂度 O(n)
     * @param arr
     * @param lo
     * @param hi
     */
    public static void mergeSort(int[] arr, int lo, int hi){
        if(arr == null || arr.length == 0){
            return;
        }
        int mid = (lo + hi) >> 1;
        if(lo < hi){
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid + 1, hi);
            merge(arr, mid, lo, hi);
        }
    }

    public static void merge(int[] arr, int mid, int lo, int hi){
        int index = 0;
        int[] temp = new int[hi - lo + 1];
        int i = lo;
        int j = mid + 1;
        while(i <= mid && j <= hi){
            temp[index++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        }
        while(i <= mid){
            temp[index++] = arr[i++];
        }
        while(j <= hi){
            temp[index++] = arr[j++];
        }
        index = 0;
        for (int k = lo; k <= hi; k++) {
            arr[k] = temp[index++];
        }
    }
```

## 快速排序

```java
    /**
     * 快速排序 不稳定
     * 利用partition分治思想
     * 通过一趟排序将待排记录分割成两部分，其中一部分记录的关键字均比另一部分的小，则可分别对这两部分记录进行排序，以达到整个序列有序的目的
     * 时间复杂度 O(nlogn)   最差情况O(n^2)
     * 空间复杂度 O(logn)
     * @param
     */
    public static void quickSort(int[] arr, int lo, int hi){
        if(lo >= hi) {
            return;
        }
        if(lo < hi){
            int index = partition(arr, lo, hi);
            quickSort(arr, lo, index - 1);
            quickSort(arr, index + 1, hi);
        }
    }

    public static int partition(int[] arr, int lo, int hi){
        int pivot = arr[lo];
        int index = lo;
        for(int i = lo; i <= hi; i++){
            if(arr[i] < pivot){
                swap(arr, i, ++index);
            }
        }
        swap(arr, lo, index);
        return index;
    }

    public static void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }


// 快排算法的真正实现
    public void sort(int[] a, int low, int high) {
        if (low >= high) return;
      // 设置这两个变量的目的是为了保持low和high不变
        int i = low, j = high; 
      // 基准数  
        int pivotNum = a[i]; 
        while (i < j) {
          // 循环结束的条件有二：一是找到比支点小的数，二是j==i
            while (a[j] >= pivotNum && j > i) { 
                j--;
            }
          // 由于上面循环结束的功能性有两个，对于找到比支点小的数，即j!=i，要进行位置的交换，下同
            if (j > i) {    
                a[i] = a[j];
                i++;
            }
            while (a[i] < pivotNum && i < j) { 
                i++;
            }
            if (i < j) {
                a[j] = a[i];
                j--;
            }
        }
        a[i] = pivotNum;
        sort(a, low, i - 1);
        sort(a, i + 1, high);
    }
```

## 插入排序

```java

    /**
     * 插入排序 稳定
     * 主要思想类似抽卡牌，将数字放到对应的位置  样本小且基本有序的时候效率高
     * 时间复杂度 O(n^2)
     * 空间复杂度 O(1)
     * @param arr
     */
    public static void insertSort(int[] arr){
        if(arr == null || arr.length == 0){
            return;
        }
        for (int i = 0; i < arr.length - 1; i++) {
            int curr = arr[i + 1];
            int index = i;
            while (index >= 0 && curr < arr[index]){
                //后移
                arr[index + 1] = arr[index];
                index--;
            }
            arr[index + 1] = curr;
//            System.out.println("【第" + i + "次插入排序】");
//            System.out.println(Arrays.toString(arr));
        }
    }

    /**
     * 希尔排序 是插入排序的改进版
     * 通过设置步长的方式对不同步长的数据进行排序，最后gap=1时整个数据合成一组，构成一组有序记录
     * 时间复杂度与gap的取值有关  当gap=1时，退化为直接插入排序 O(n^2)
     * @param arr
     */
    public static void shellSort(int[] arr){
        int cnt = 0;
        //Knuth序列
        int h = 1;
        while(h <= arr.length / 3){
            h = 3 * h + 1;
        }
        for(int gap = h; gap > 0; gap = (gap - 1) / 3){
            for(int i = gap; i < arr.length; i++){
                for(int j = i; j > 0 && j - gap >= 0; j -= gap){
                    if(arr[j] < arr[j - gap]){
                        swap(arr, j, j - gap);
                    }else{
                        break;
                    }
                }
            }
            cnt++;
//            System.out.println("【第" + cnt + "次希尔排序】");
//            System.out.println(Arrays.toString(arr));
        }
    }
```

## 冒泡排序与选择排序

```java
    /**
     * 冒泡排序  最稳定的排序算法之一
     * 主要思想就是将大的数字往后放，每次相邻比较交换
     * 时间复杂度 O(n^2)
     * 空间复杂度O(1) 不占用额外空间
     * @param arr
     */
    public static void bubbleSort(int[] arr){
        if(arr == null || arr.length == 0) {
            return;
        }
        boolean flag = false;
        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if(arr[j] > arr[j + 1]){
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = true;
                }
            }
            //倘若未发生交换，则说明数组本身有序，可直接返回
            if(!flag){
                return;
            }
//            System.out.println("【第" + i + "次冒泡排序】");
//            System.out.println(Arrays.toString(arr));
        }
    }
    /**
     * 选择排序 最稳定的排序算法之一
     * 主要思想是在未排序序列中找到最小的数字并将其放到已排序数组的末尾
     * 时间复杂度 O(n^2)
     * 空间复杂度 O(1)
     * @param arr
     */
    public  static void selectSort(int[] arr){
        if(arr == null || arr.length == 0){
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIndex]){
                    minIndex = j;
                }
            }
            swap(arr, minIndex, i);
//            System.out.println("【第" + i + "次选择排序】");
//            System.out.println(Arrays.toString(arr));
        }
    }
```

# 二叉树遍历

## 先序遍历

```java
/**
         * 非递归前序遍历
         * @param root
         * @return
         */
        public List<Integer> preorderTraversal(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            if (root == null) {
                return res;
            }
            Stack<TreeNode> s = new Stack<>();
            s.push(root);
            while (!s.isEmpty()) {
                TreeNode node = s.pop();
                res.add(node.val);
                if (node.right != null) {
                    s.push(node.right);
                }
                if (node.left != null) {
                    s.push(node.left);
                }
            }
            return res;
        }
```

## 中序遍历

```java
 /**
         * 非递归中序遍历
         * @param root
         * @return
         */
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            if (root == null) {
                return res;
            }
            Stack<TreeNode> s = new Stack<>();
            TreeNode node = root;
            while (node != null || !s.isEmpty()) {
                if (node != null) {
                    s.push(node);
                    node = node.left;
                } else {
                    node = s.pop();
                    res.add(node.val);
                    node = node.right;
                }
            }
            return res;
        }
```

## 后序遍历

```java
/**
* 非递归后序遍历
* @param root 根节点
*后序遍历递归定义：先左子树，后右子树，再根节点。
	后序遍历的难点在于：需要判断上次访问的节点是位于左子树，还是右子树。
		若是位于左子树，则需跳过根节点，先进入右子树，再回头访问根节点；
		若是位于右子树，则直接访问根节点。
*/
        public List<Integer> postorderTraversal(TreeNode root) {
            List<Integer> res = new ArrayList<>();
            if (root == null) {
                return res;
            }
            Stack<TreeNode> s = new Stack<>();
            TreeNode node = root;
            //用于标记上一次访问的节点
            TreeNode pre = null;
            while (node != null || !s.isEmpty()) {
                while (node != null) {
                    s.push(node);
                    node = node.left;
                }
                if (!s.isEmpty()) {
                    node = s.peek();
                    if (node.right == null || node.right == pre) {
                        node = s.pop();
                        res.add(node.val);
                        pre = node;
                        node = null;
                    } else {
                      //如果上次访问的节点是左子树,则进入右子树
                        node = node.right;
                    }
                }
            }
            return res;
        }
```

# 多线程编程

## LockCondition

```java
package com.sheva.thread;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author Sheva
 * @Date 2020/8/11
 */
public class LockConditionThread {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        Lock lock = new ReentrantLock();
        Condition conditionT1 = lock.newCondition();
        Condition conditionT2 = lock.newCondition();
        new Thread(() -> {
            try{
                lock.lock();
                for (char c : aI) {
                    System.out.print(c + " ");
                    conditionT2.signal();
                    conditionT1.await();
                }
                conditionT2.signal();
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }, "t1").start();
      
        new Thread(() -> {
            try {
                lock.lock();

                for (char c : aC) {
                    System.out.print(c + " ");
                    conditionT1.signal();
                    conditionT2.await();
                }
                conditionT1.signal();
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }, "t2").start();
    }
}

```

## wait notify

```java
package com.sheva.thread;
/**
 * @Author Sheva
 * @Date 2020/8/11
 */
public class SyncThread {

    public static void main(String[] args) {
        final  Object o = new Object();
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(() -> {
            synchronized (o){
                for (char c : aI) {
                    System.out.print(c + " ");
                    try {
                        //唤起某个线程
                        o.notify();
                        //让出锁
                        o.wait();
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (o){
                for (char c : aC) {
                    System.out.print(c + " ");
                    try {
                        o.notify();
                        o.wait();
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t2").start();
    }
}

```

## CasThread

```java
package com.sheva.thread;

/**
 * @Author Sheva
 * @Date 2020/8/11
 * 自旋锁
 */
public class CasThread {
    enum ReadyToRun {T1, T2}
    static volatile ReadyToRun r = ReadyToRun.T1;
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        new Thread(() -> {
            for (char c : aI){
                while (r != ReadyToRun.T1){}
                System.out.print(c + " ");
                r = ReadyToRun.T2;
            }
        }, "t1").start();

        new Thread(() -> {
            for (char c : aC) {
                while (r != ReadyToRun.T2) {}
                System.out.print(c + " ");
                r = ReadyToRun.T1;
            }
        }, "t2").start();
    }
}
```

## LockSupport

```java
package com.sheva.thread;
import java.util.concurrent.locks.LockSupport;

/**
 * @Author Sheva
 * @Date 2020/8/11
 * LockSupport
 */
public class LockSupportThread {
    static Thread t1 = null;
    static Thread t2 = null;
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();

        t1 = new Thread(() -> {
            for (char c : aI) {
                System.out.print(c + " ");
                LockSupport.unpark(t2);
                LockSupport.park();
            }
        }, "t1");

        t2 = new Thread(() -> {
            for (char c : aC){
                LockSupport.park();
                System.out.print(c + " ");
                LockSupport.unpark(t1);
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

# 前端

## HTML5

### DOCTYPE

<!DOCTYPE>声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析

- **标准模式：**浏览器的解析规则都是按照最新的标准进行解析的。
- **兼容模式：**浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。 

html5只需要写<!DOCTYPE HTML> 而不需要引入DTD（Document Type Definition）的主要原因是

- HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）
- HTML4基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型

### SGML, HTML, XML, XHTML

- **SGML（Standard Generalized Markup Language）** 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。
- **HTML（Hyper Text Markup Language）**是超文本标记语言，主要是用于规定怎么显示网页。
- **XML（Extensible Markup Language）** 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多， 而 HTML 的标签都是固定的而且数量有限。
- **XHTML（Extensible HyperText Markup Language）** 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。

### DTD介绍

- **DTD（ Document Type Definition 文档类型定义）**是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元 素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。
- DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。

### 行内元素  块元素  空元素

**空元素**

- 标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。
- 常见的空元素有：br hr img input link meta

**行内元素**：a span img input select

**块级元素**： div（文档分区） ul（无序列表）  ol（有序列表）  dl（定义列表） 

 dd（定义列表中定义条目描述） dt（自定义列表项）  h1（标题级别）   p（行） 

### 语义化

- 语义化，顾名思义，就是你写的HTML结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。不仅对自己来说，容易阅读，书写。别人看你的代码和结构也容易理解，甚至对一些不是做网页开发的人来说，也容易阅读。那么，我们以后再开发的过程中，一定要注意了，尽量使用官方的有语义的标签，不要再使用一堆无意义的标签去堆你的结构。
-  语义化，也无非就是自己在使用标签的时候多使用有英文语义的标签，比如h标签，在HTML中就是就是用来定义标题，还有p标签，英文是paragraph段落，table表格标签,等等。

### meta viewport

- 移动端浏览器通常都在一个比屏幕更宽的虚拟窗口中渲染页面，这个虚拟窗口就是viewport，目的是正常展示没有做移动端适配的网页，可以让他们完整的展现给用户。我们有时用移动设备访问桌面版网页就会看到一个横向滚动条，这里可显示区域的宽度就是viewport的宽度。

- <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。当然maximum-scale=1.0, user-scalable=0不是必需的，是否允许用户手动播放根据网站的需求来定，但把width设为width-device基本是必须的，这样能保证不会出现横向滚动条。

- meta viewport 的6个属性：

> | width         | 设置layout viewport 的宽度，为一个正整数，或字符串”width-device” |
> | ------------- | ------------------------------------------------------------ |
> | initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数                 |
> | minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数                 |
> | maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数                 |
> | height        | 设置layout viewport 的高度，这个属性并不重要，很少使用       |
> | user-scalable | 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 |

### link与@import的区别

- 从属关系区别。@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性、引入网站图标等。

- 加载顺序区别。加载页面时，link标签引入的CSS文件被同时加载；而@import引入的CSS文件将在页面加载完毕后被加载。

- 兼容性区别。@import时CSS 2.1才有的语法，故只可在IE5+才能识别；link标签作为HTML标签，不存在兼容性问题。

- DOM可控性区别。可以通过JS操作DOM，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方法插入样式。

### html5标签

| <article>    | 定义独立的内容                                   |
| ------------ | ------------------------------------------------ |
| <aside>      | 定义页面内容之外的内容                           |
| <audio>      | 定义声音内容                                     |
| <bdi>        | 定义文本的文本方向，使其脱离其周围文本的方向设置 |
| <canvas>     | 定义图形                                         |
| <command>    | 定义命令按钮                                     |
| <datalist>   | 定义下拉列表                                     |
| <details>    | 定义元素的细节                                   |
| <embed>      | 定义外部交互内容或插件                           |
| <figcaption> | 定义figure元素的标题                             |
| <figure>     | 定义媒介内容的分组，以及他们的标题               |
| <footer>     | 定义section或page的页脚                          |
| <header>     | 定义section或page的页眉                          |
| <hgroup>     | 定义有关文档中的section信息                      |
| <keygen>     | 定义生成密钥                                     |
| <mark>       | 定义有记号的文本                                 |
| <meter>      | 定义预定义范围内的度量                           |
| <nav>        | 定义导航链接                                     |
| <output>     | 定义输出的一些类型                               |
| <progress>   | 定义任何类型的任务的进度                         |
| <rp>         | 定义若浏览器不支持ruby元素显示的内容             |
| <rt>         | 定义ruby注释的解释                               |
| <ruby>       | 定义ruby注释                                     |
| <section>    | 定义section                                      |
| <source>     | 定义媒介源                                       |
| <summary>    | 定义details元素的标题                            |
| <time>       | 定义日期/时间                                    |
| <track>      | 定义用在媒体播放器中的文本轨道                   |
| <video>      | 定义视频                                         |

### Label的作用与用法

label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

```html
<label for="Name">Number:</label> 
<input type=“text“ name="Name" id="Name"/>
```

## CSS

### 盒子模型

（1） **概念：**每个元素被表示为一个矩形的盒子，由四个部分组成：内容（content）， 内边距（padding），边框（border），外边距（margin）。它在页面中所占的实际大小（宽高）是content+padding+border+margin之和

（2）**盒子模型有两种：**标准盒模型（W3C盒模型），IE盒模型

（3）**两种盒模型的区别：**标准盒模型内容大小就是content大小，而IE盒模型内容大小则是content+padding+border总的大小。

（4）**怎么设置两种盒模型：**通过设置box-sizing属性为content-box（默认值，标准盒模型）、border-box（IE盒模型）。

（5）**box-sizing使用场景：**若设置子元素的margin或border时可能会撑破父元素的尺寸，就需要使用box-sizing:border-box来将border包含进元素的尺寸中。

### box-sizing属性

用来控制元素的盒子模型的解析模式，默认为content-box

**context-box：**W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽

**border-box：**IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽

### CSS选择器  哪些属性可以继承

通配符选择器（*）   id选择器（#classId）   类选择器（.className）  标签选择器（div，h1，p，span，table）  子选择器（ul > li）
后代选择器（li a）  伪类选择器（a:hover，li:nth-child）

可继承的属性：font-size, font-family, color

不可继承的样式：border, padding, margin, width, height

优先级（就近原则）：!important > [ id > class > tag ]
!important 比内联优先级高

### postion（方位）的值

**static（默认）：**默认值，没有定位

**relative（相对定位）：**生成相对定位的元素，相对于其正常位置进行定位，参考自身静态位置通过 top, bottom, left, right 定位；

**absolute(绝对定位)：**参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；

**fixed(固定定位)：**生成绝对定位的元素，相对于浏览器窗口进行定位

**inherit**：规定应该从父元素继承position属性的值

## JS

### 语言特性

- 解释性：js是一门解释语言，源码不需要经过编译，直接就可以在浏览器上运行时被解释
- 基于对象：js是一种基于对象的语言，能够运用自己已经创建了的对象，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用
- 事件驱动：js可以直接对用户或客户输入做出相应，无需经过web服务程序。他对用户的相应，是以事件驱动的方式进行的，所谓事件驱动，指的是在主页执行了某种操作所产生的动作，此动作成为”事件“
- 跨平台：js依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并支持js的浏览器就可以正确执行
- 安全性：js是一种安全性语言。它不允许访问本地磁盘，也不能将数据存入服务器上；不允许对网络文本进行修改和删除，只能通过浏览器实现信息浏览或动态交互。可以有效的防止数据丢失

### DOM与BOM

- **DOM:document object model** 文档对象模型,提供操作页面元素的方法和属性
- **BOM:browser object model** 浏览器对象模型，提供一些属性和方法可以操作浏览器

**动态操作DOM的方法**

`document.createElement`;创建元素 
`appendChild` : 向元素的末尾添加子节点； 
`removeChild` : 删除子节点； 
`replaceChild` : 替换节点； 
`insertBefore` :把元素节点插入某个节点的前面 
`cloneNode` : 复制节点； 
`set/get/remove Attribute` : 设置自定义行内属性；

### innerHTML和innerText的区别

- **innerHTML：**可以识别标签
- **innerText：**不能识别标签；会把所有东西当做文本

### 数据类型相关问题

**基本数据类型**

number string boolean null undefined

**null与undefined的区别**

undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。因此，可以把undefined看作是空的变量，而null看作是空的对象

**常见null的情况**

- 通过id获取元素，如果id名字不存在，则返回null
- 通过正则进行捕获时，如果没有捕获到内容，那么结果是null
- 在清空对象，销毁堆内存时，给对象赋值null

**常见undefined情况**

- 获取对象属性名对应的属性值时如果属性名不存在，返回undefined
- 函数的形参如果没有实参赋值，在函数中默认存储为undefined
- 如果函数没有return，那么函数的返回值是undefined
- 如果变量只声明，没有赋值，那么默认存储也是undefined

**引用数据类型**

普通的对象、数组、正则、Date实例、Math

**函数数据类型**

普通函数 类

**基本数据类型和引用数据类型的区别**

- 基本数据类型存储到栈内存中，引用数据类型存储到堆内存中 
- 基本数据类型操作值的，引用数据类型操作的是空间地址；

### Number Math  字符串 数组 的方法

**Number的方法**

`isNaN` : 强制转换成number，在判断 
`Number` :将其他数据类型的值强制转换成number类型； 
`parseInt` :经常用于字符串提取数字的方法； 
`parseFloat`:和parseInt 用法一样；区别是多识别一位小数点 
`toFixed` : 保留小数点位数的方法;返回值是一个字符串；

**Math的方法**

`Math.abs()`: 取绝对值； 
`Math.floor()` : 向下取整 
`Math.ceil()` : 向上取整 
`Math.max()` : 取最大值 
`Math.min()` : 取一组数的最小值 
`Math.random()` 取随机数，取值范围[0,1) 
`Math.round()`: 四舍五入取整 
取m-n之间的随机整数：`Math.round(Math.random()*(n-m)+m)` 
`Math.pow()` : 取幂次方 
`Math.sqrt()` : 开平方；

**字符串的方法**

`toUpperCase` : 把小写字母转成大写 
`toLowerCase` 把大写转小写 
`charAt` : 通过索引获取字符 
`charCodeAt` : 通过索引获取对应字符的Unicode编码； 
`substr` : 截取 substr(m,n) 从索引m开始，截取n个字符； 
`substring`: substring(m,n) ：从索引m开始，截取到索引n，不包含n; (不支持负数) 
`slice(m,n)`: substring; 从索引m开始，截取到索引n，不包含n (支持负数) 
`indexOf` : 检测字符在字符串中第一次出现的索引位置； 
`lastIndexOf` : 检测字符在字符串中最后一次出现的索引位置； 
`split`: 把字符串按照特定的字符分隔数组中的每一项； 
`replace`:替换;原有字符串不变；用新字符替换旧的字符 
`concat` : 拼接 
`trim` : 去空格 : 去除字符串中左右的空格；

**数组的方法**

`push` ：向数组末尾新增一项；可以传多个； 
`pop` ： 删除数组的最后一项；不需要传参数； 
`unshift` ：向数组开头新增一项；需要传参数； 
`shift` ：删除数组的第一项；不需要传参

`sort`：数组的排序 
`reverse`：将数组颠倒 
原有数组发生改变；

`concat`：数组的拼接 
`join`：数组的连接 
`indexOf`：第一次出现的索引位置 
`lastIndexOf`：最后一次出现的索引位置 
`map`：数组的遍历和映射 
`forEach`：遍历数组 
`toString`：转字符串 
原有数组不发生改变；

`slice` ：数组的截取 
slice(m,n): 从数组索引m开始，截取到索引n，但是不包含n;[前包后不包] 
slice(m) : 从索引m开始，截取到末尾； 
slice():数组的克隆 slice(0); 
原有数组不发生改变；

`splice`：删除数组中的某几项 
splice(m,n): 从索引开始，删除n个 
splice(m) : 从索引m开始删除到末尾； 
splice(0): 
splice(m,x,n);替换从索引m开始，删除x个，用n替换； 
原有数组发生改变

### 获取元素的方法

`document.getElementById`:通过ID名来获取元素 
`document.getElementsByTagName`: 通过标签名来获取元素 
`document.getElementsByClassName()`; 类数组集合； 
`document.getElementsByName`;通过name属性来获取元素； 
`document.documentElement` 获取当前的html 
body :获取页面的body元素； 
`document.querySelector()`;如果是id名加#，如果是class名加. 
`document.querySelectorAll()`;获取所有的元素

## VUE

### MVVM开发模式

**MVVM分为Model、View、ViewModel**

- Model代表数据模型，数据和业务逻辑都在Model层中定义
- View代表UI视图，负责将数据模型转化为UI进行展示
- ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作

Model和View并无直接关联，而是通过ViewModel来进行联系，Model和ViewModel之间有着双向数据绑定的联系

这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom

### v-if与v-show的区别

- v-show仅仅控制元素的显示方式，将display属性在block和none进行切换，适合用于频繁切换的情况
- v-if会销毁dom并且重新创建，是真正的条件渲染，首次加载开销比较大，适合用于切换频率较低的情况

### 常见指令

- v-model：用于表单元素实现双向数据绑定
- v-for：类似js的遍历，其中数据类型可以是Array|Object|number|string
- v-show：显示内容，和v-if一样，区别是if是注释掉；而v-show是给一个display:none的属性让他不显示
- v-hide：用于隐藏内容
- v-if：后面跟的是一个布尔表达式，值为true和false
- v-else：必须和v-if一起用，不能单独使用，而且必须在v-if下面，中间有别的标签也会报错
- v-bind：动态绑定 及时对页面的数据进行更改
- v-bind:class： 三种绑定方法  1、对象型  '{red:isred}'  2、三元型  'isred?"red":"blue"'  3、数组型  '[{red:"isred"},{blue:"isblue"}]'
- v-on:click：给标签绑定函数，可以缩写为@，例如绑定一个点击函数  函数必须写在methods里面
- v-html：解析html标签
- v-text：解析文本，给标签加了一个v-text 会覆盖标签内部原先的内容
- v-once：进入页面时，只渲染一次 不在进行渲染
- v-cloak：防止闪烁
- v-pre：把标签内部的元素原位输出

### Vue组件之间的参数传递

- 父组件与子组件的传值

  - 父->子：子组件通过props方法接收数据
  - 子->父：$emit方法传递参数

- 非父子组件间的数据传递，兄弟组件传值

  通过第三者eventBus.js，创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件

### computed和methods的区别

- methods使用时，一般需要加括号，而computes不需要

  computed本身是一个属性，本质是内部的set和get方法，最终得到的结果也是get方法的返回值

- computed带缓存机制，在其内部变量不变或者返回值不变的情况下多次调用只会执行一次，后续执行时会直接从缓存中获取该computed的结果